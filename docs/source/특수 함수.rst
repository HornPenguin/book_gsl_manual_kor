.. index:: 특수 함수

**********************************
특수 함수 (Special Functions)
**********************************

이 단원에서는 GSL의 특수 함수들을 기술합니다. 
이 라이브러리는 Airy 함수, Bessel 함수, Clausen 함수, Coulomb 파동함수, 
커플링 계수, Dawson 함수 Debye 함수, Dilogarithms, 타원 적분, 자코비 타원적분, 
오류함수, 지수적 적분, 페르미-디렉 함수, Gamma 함수, Gegenbauer 함수, 
Hermite 다항식과 함수, Hypergeometric 함수, Larguerre 함수, Legendre 함수, 
Spherical Harmonics, Psi(Digamma)함수, Synchrotron 함수, Transport 함수, 
삼각함수, 제타 함수 등을 제공합니다. 

각각의 명령어는 수치적 오류와 함수의 값을 계산해서 반환합니다.

이 단원에서 기술된 함수들은 각각 다른 헤더파일에 정의되어 있습니다. 
예를 들어서 ``gsl_sf_airy.h``나 ``gsl_sf_bessel.h``기 있습니다. 
모두 포함시켜서 계산하려면, ``gsl_sf.h``을 포함시키면 됩니다.


함수의 사용 (Usage)
====================

이 단원에 기술된 함수들은 두 가지 형태로 호출할 수 있습니다. 
하나는 함수의 값을 불러오는 호출입니다. 이는 주어진 인자에 대한 함수의 수치값을 반환합니다. 
다른 하나는 오류 관리를 위한 호출 형태입니다. 
이 호출은 함수 값과 함께 오류 값을 반환합니다. 
이 두 가지 호출 형태는 모두 동일한 코드에 접근합니다. 
즉, 오류 관리 호출에서 얻은 계산 값과 곧바로 계산 값을 받는 호출에서 얻은 계산 값은 정확히 동일합니다. 
적어도 동일한 과정을 거친 계산입니다(\*).

함수 값을 불러오는 호출은 말 그대로 인자에 대해 값을 계산한 수치 값만을 반환합니다. 
이는 곧바로 수학 수식 표현에 사용할 수 있습니다. 
예를 들어서 다음의 함수 호출은 베셀 함수 :math:`J\_0 (x)` 의 값을 계산합니다.

.. code-block:: C

    double y = gsl_sf_bessel_J0(x);


이 방법은 오류 코드를 확인하거나 오차 값을 계산할 수 없습니다. 
이러한 정보를 얻기 위해서는 오류 관리 호출 형태로 대체해서 해당 정보를 저장할 변수를 인자에 하나 더 추가해야 합니다.
::

    gsl_sf_result result;
    int status = gsl_sf_bessel_J0_e (x, &result);


이러한 오류 관리 함수는 :code:`_e` 접미사를 가지고 있습니다. 
반환 값은 오류의 조건을 나타냅니다. 대표적으로 오버플로우, 언더플로우 아니면 오차를 나타냅니다. 
만약, 오류가 없다면 오류 관리 함수는  :code:`GSL_SUCCESS` 값을 반환합니다.

gsl_sf_result 구조체 (The gsl_sf_result struct)
--------------------------------------------------

이러한 특수 함수들은 결과 값을 계산하는 과정에서 오차를 함께 계산합니다. 
따라서, 이러한 오차와 결과값을 함께 다룰 수 있는 구조체를 함께 제공합니다. 
이 구조체는 헤더파일  ``gsl_sf_result.h``  정의되어 있습니다.

이 구조체는 다음과 같이 함수 값과 오차 값으로 이루어져 있습니다.

.. type:: gsl_sf_result

  ::

    typedef struct
    {
      double val;
      double err;
    } gsl_sf_result;


  :data:`val`는 함수의 값을 저장하고, :data:`err`는 함수 값의 절대 오차를 나타냅니다.

몇몇 경우에, 오버플로우나 언더플로우가 함수에 의해 감지될 수 있습니다. 
그러한 경우에 크기를 나타내는 지수 값을 오차/값 쌍과 함께 반환할 수도 있습니다. 
이러한 방법은 내장된 변수의 동적 크기를 초과해서 결과를 나타낼 수 있는 장점이 있습니다. 
이를 위해 다음과 같이 함수 값, 오차, 그리고 지수 값을 포함하는 구조체를 사용합니다. 
실제 값은 :code:`result * 10^(e10)`을 계산해야 합니다.


.. type:: gsl_sf_result_e10

  ::

    typedef struct
    {
      double val;
      double err;
      int    e10;
    } gsl_sf_result_e10;


모드 (Modes)
-------------------------

이 라이브러리의 특수 함수 구현체들의 제공 목적은 배정밀도를 가지는 특수 함수 값의 제공을 위함입니다. 
그러나 몇몇 특수 함수들의 경우, 배정밀도 수준의 정밀도를 얻기 위해서 매우 높은 항이 필요한 경우도 있습니다. 
이러한 경우에 :type:`gsl_mode_t` 자료형으로 정의된 :code:`mode` 인자를 이용해 요구 정밀도를 낮추어 연산 효율을 높일 수 있습니다. 다음의 정밀도 값들이  ``mode`` 인자에 들어갈 수 있습니다.

.. type:: gsl_mode_t

  .. macro:: GSL_PREC_DOUBLE

    배정밀도, 근사적으로  :math:`2 \cdot 10^{-16}` 의 상대 정확도를 가짐.

  .. macro:: GSL_PREC_SINGLE

    단정밀도, 근사적으로  :math:`1 \cdot 10^{-7}` 의 상대 정확도를 가짐.

  .. macro:: GSL_PREC_APPROX

    근사 값, 근사적으로  :math:`5 \cdot 10^{-4}` 의 상대 정확도를 가짐.


근사 상태는 가장 빠른 계산 시간을 보장하지만 가장 낮은 정확도를 가집니다.


에어리 함수와 도함수(Airy function & Derivative)
================================================
.. include:: 특수 함수-에어리.rst

베셀 함수(Bessel function)
================
.. include:: 특수 함수-베셀.rst

Clausen Functions
=================
.. include:: specfunc-clausen.rst

Coulomb Functions
=================
.. include:: specfunc-coulomb.rst

Coupling Coefficients
=====================
.. include:: specfunc-coupling.rst

Dawson Function
===============
.. include:: specfunc-dawson.rst

Debye Functions
===============
.. include:: specfunc-debye.rst

.. _dilog-function:

Dilogarithm
===========
.. include:: specfunc-dilog.rst

Elementary Operations
=====================
.. include:: specfunc-elementary.rst

Elliptic Integrals
==================
.. include:: specfunc-ellint.rst

Elliptic Functions (Jacobi)
===========================
.. include:: specfunc-elljac.rst

Error Functions
===============
.. include:: specfunc-erf.rst

Exponential Functions
=====================
.. include:: specfunc-exp.rst

Exponential Integrals
=====================
.. include:: specfunc-expint.rst

Fermi-Dirac Function
====================
.. include:: specfunc-fermi-dirac.rst

Gamma and Beta Functions
========================
.. include:: specfunc-gamma.rst

Gegenbauer Functions
====================
.. include:: specfunc-gegenbauer.rst

Hermite Polynomials and Functions
=================================
.. include:: specfunc-hermite.rst

Hypergeometric Functions
========================
.. include:: specfunc-hyperg.rst

.. _laguerre-functions:

Laguerre Functions
==================
.. include:: specfunc-laguerre.rst

Lambert W Functions
===================
.. include:: specfunc-lambert.rst

Legendre Functions and Spherical Harmonics
==========================================
.. include:: specfunc-legendre.rst

Logarithm and Related Functions
===============================
.. include:: specfunc-log.rst

Mathieu Functions
=================
.. include:: specfunc-mathieu.rst

Power Function
==============
.. include:: specfunc-pow-int.rst

Psi (Digamma) Function
======================
.. include:: specfunc-psi.rst

Synchrotron Functions
=====================
.. include:: specfunc-synchrotron.rst

Transport Functions
===================
.. include:: specfunc-transport.rst

Trigonometric Functions
=======================
.. include:: specfunc-trig.rst

Zeta Functions
==============
.. include:: specfunc-zeta.rst


예제 (Examples)
========================

다음 예제는 오차 관리 형태의 특수 함수를 사용하는 방법을 보여줍니다. 
베셀 함수 :math:`J\_0 (5.0)`을 사용했습니다.

.. code-block:: c

  #include <stdio.h>
  #include <gsl/gsl_errno.h>
  #include <gsl/gsl_sf_bessel.h>

  int
  main (void)
  {
    double *x* = 5.0;
    gsl_sf_result result;

    double expected = -0.17759677131433830434739701;

    int status = gsl_sf_bessel_J0_e (x, &result);

    printf ("status  = %s\n", gsl_strerror(status));
    printf ("J0(5.0) = %.18f\n"
            "      +/- % .18f\n",
            result.val, result.err);
    printf ("exact   = %.18f\n", expected);
    return status;
  }


다음은 프로그램의 출력 결과입니다.

.. code-block:: bash

  status  = success
  J0(5.0) = -0.    177596771314338264
        +/-  0.    00000000000000019   3
  exact   = -0.    177596771314338292


다음 프로그램은 같은 함수(베셀 함수)로 똑같은 값(:math:`J\_0 (5.0)`)을 계산합니다. 
이 때, ``result.err`` 반환 상태는 존재하지 않습니다.

.. code-block:: c

  #include <stdio.h>
  #include <gsl/   gsl_sf_bessel.h>

  int
  main (void)
  {
    double *x* = 5.0;
    double expected = -0.  177596771314338304347     39701;

    double y =     gsl_sf_bessel_J0 (x);

    printf ("J0(5.0) = %.  18f\n", y);
    printf ("exact   = %.  18f\n", expected);
    return 0;
  }


출력 결과는 다음과 같습니다.

.. code-block:: bash

    J0(5.0) = -0.177596771314338264
    exact   = -0.177596771314338292


참고문헌과 추가자료
==============================

이 라이브러리는 다음 책의 규약을 따릅니다 [#AS]_ .

- Handbook of Mathematical Functions, edited by Abramowitz & Stegun, Dover, ISBN 0486612724.

다음 논문들은 특수 함수들을 계산하기 위한 알고리즘에 관한 내용입니다.

* Allan J. MacLeod, MISCFUN: A software package to compute uncommon
  special functions.  ACM Trans. Math. Soft., vol.: 22,
  1996, 288--301

* Bunck, B. F., A fast algorithm for evaluation of normalized Hermite
  functions, BIT Numer. Math, 49: 281-295, 2009.

* G.N. Watson, A Treatise on the Theory of Bessel Functions,
  2nd Edition (Cambridge University Press, 1944).

* G. Nemeth, Mathematical Approximations of Special Functions,
  Nova Science Publishers, ISBN 1-56072-052-2

* B.C. Carlson, Special Functions of Applied Mathematics (1977)

* N. M. Temme, Special Functions: An Introduction to the Classical
  Functions of Mathematical Physics (1996), ISBN 978-0471113133.

* W.J. Thompson, Atlas for Computing Mathematical Functions, John Wiley & Sons,
  New York (1997).

* Y.Y. Luke, Algorithms for the Computation of Mathematical Functions, Academic
  Press, New York (1977).

* S. A. Holmes and W. E. Featherstone, A unified approach to the Clenshaw
  summation and the recursive computation of very high degree and order
  normalised associated Legendre functions, Journal of Geodesy, 76,
  pg. 279-299, 2002.

.. route:: 각주

.. [#AS] 미국 표준 기술 연구소에서 Milton Abramowitz와 Irene Stegun이 편집한 수학적 문헌으로 수식, 그래프 및 수학표를 포함하는 수학 함수 핸드북입니다.(\*)



# 클라우센 함수 (Clausen Functions)

클라우센 함수는 다음과 같이 적분으로 정의됩니다.

 :math:`$Cl_2(x) = - \int_0^x \log(2 \sin (\frac{t}{2})) \, dt` $

이 함수는 다이로그 함수와 다음과 같은 관계를 가집니다.  :math:`Cl_2 (\theta) = \Im[Li_2 (e^{i \theta})]`  클라우센 함수들은 헤더 파일  ``gsl_sf_clausen.h``  정의되어 있습니다.

> double **gsl_sf_clausen**(double *x*)<br>
> int **gsl_sf_clausen_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 클라우센 적분  :math:`Cl_2(x)` 의 값을 계산합니다.

# 쿨롱 함수 (Coulomb Functions)

쿨롱 함수의 초안은 헤더 파일  ``gsl_sf_coulomb.h``  정의되어 있습니다. 구속 상태와 산란해를 모두 포함합니다.

정규화된 수소의 구속 상태(Normalized Hydrogenic Bound States)
-------------------------

>double **gsl_sf_hydrogenicR_1**(double *Z*, double *r*)<br>
>int **gsl_sf_hydrogenicR_1_e**(double *Z*, double *r*, gsl_sf_result * *result*)

이 함수들은 가장 낮은 차수의 정규화 된 수소의 구속 방사형 상태  함수  :math:`R_1 = 2 Z \sqrt{Z} \exp (-Zr)` 를 계산합니다.

>double **gsl_sf_hydrogenicR**(int *n*, int *l*, double *Z*, double *r*)<br>
>int **gsl_sf_hydrogenicR_e**(int *n*, int *l*, double *Z*, double *r*, gsl_sf_result * *result*)

이 함수들은  ``n`` 차수의 정규화된 수소의 구속 방사형 상태 함수 

 :math:`$R_n := \frac{2 Z^{3/2}}{n^2} (\frac{2Zr}{n})^l \sqrt{\frac{(n-l-1)!}{n+l}} \exp(-Zr /n) L_{n-l-1}^{2l+1} (2Zr/n)` $

를 계산합니다.  :math:`L_b^a(x)` 는 일반화 된 르장드르 다항식입니다. 이 정규화 방법은 수소의 파동 함수 :math:`\psi` 가  :math:`\psi(n,l,r) = R_n Y_{lm}` 로 주어지도록 정해졌습니다.

쿨롱 파동 함수(Coulomb Wave Functions)
-------------------------

쿨롱 파동함수  :math:`F_L(\eta,x), G_L (\eta,x)` 들은 Abramowitz & Stegun Chapter 14에 기술되어 있습니다. 이 함수들은 다양하고 넓은 범위의 값들을 가지기 때문에, 오버플로우를 이용할 수 있도록 구현되었습니다. 만약, 오버플로우가 발생한다면,  ``GSL_EOVERFLW`` 신호가 나오고  ``exponent(s)``  수정 가능한 인자  ``exp_F``   ``exp_G``  함께 반환됩니다. 완전해는 다음과 같이 구할 수 있습니다.

 :math:`$F_L(\eta,x) = f_c[k_L] * \exp(exp_F)` $

 :math:`$G_L(\eta,x) = g_c[k_L] * \exp(exp_G)` $

 :math:`${F'}\_L(\eta,x)= f_{cp}[k_L] * \exp(exp_F)` $

 :math:`${G'}\_L(\eta,x)= g_{cp}[k_L] * \exp(exp_G)` $

>int **gsl_sf_coulomb_wave_FG_e**(double *eta*, double *x*, double *L_F*, int *k*, gsl_sf_result *F, gsl_sf_result * *Fp*, gsl_sf_result * *G*, gsl_sf_result * *Gp*, double * *exp_F*, double * *exp_G*)

이 함수는 쿨롱 파동 함수  :math:`F_L(\eta,x), G_{L-k}(\eta,x)` 와 그 도함수  :math:`F'_L(\eta,x), G'_{L-k}(\eta,x)` 를 인자  :math:`x` 에 대해 계산합니다. 각 계수들은  :math:`L` 에 대해 다음의 제약조건을 가집니다.  :math:`L-k > -1/2, x>0, k \in \mathbb{Z}`  유의 점은  :math:`L` 이 반드시 정수로 있을 필요는 없다는 점입니다. 결과 값들은 인자  ``F``  ``G``  함수의 값이 저장되고, 도함수의 값은  ``Fp``   ``Gp``  저장됩니다. 오버플로우가 발생하면,  ``GSL_EOVERFLW``  반환되고 조정된 지수값이 수정 가능한 인자  ``exp_F``   ``exp_G``  저장됩니다.

>int **gsl_sf_coulomb_wave_F_array**(double *L_min*, int *kmax*, double *eta*, double *x*, double *fc_array*[], double * *F_exponent*)

이 함수는  :math:`L = Lmin \dots Lmin + kmax` 에 대해, 함수  :math:`F_L(\eta,x)` 의 값을 계산합니다.  계산 결과값은  ``fc_array`` 배열에 저장됩니다. 오버플로우가 발생하면 지수값이  ``F_exponenet``  저장됩니다.

>int **gsl_sf_coulomb_wave_FG_array**(double* L_min*, int *kmax*, double *eta*, double *x*, double *fc_array*[], double *gc_array*[], double * *F_exponent*, double * *G_exponent*)

이 함수는  :math:`L = Lmin \dots Lmin + kmax` 에 대해, 함수  :math:`F_L(\eta,x), G_L(\eta,x)` 의 값을 계산합니다.  계산 결과값은 각각  ``fc_array``   ``gc_array`` 배열에 저장됩니다. 오버플로우가 발생하면 지수값이  ``F_exponenet``   ``G_exponent``  저장됩니다.


>int **gsl_sf_coulomb_wave_FGp_array**(double *L_min*, int *kmax*, double *eta*, double *x*, double *fc_array*[], double *fcp_array*[], double *gc_array*[], double *gcp_array*[], double * *F_exponent*, double * *G_exponent*)

이 함수는  :math:`L = Lmin \dots Lmin + kmax` 에 대해, 함수  :math:`F_L(\eta,x), G_L(\eta,x)` 와 그 도함수  :math:`F'_L(\eta,x), G'_L(\eta,x)` 의 값을 계산합니다.  계산 결과값은 각각  ``fc_array``   ``gc_array``  ``fcp_array`` 그리고  ``gcp_array`` 배열에 저장됩니다. 오버플로우가 발생하면 지수값이  ``F_exponenet``   ``G_exponent``  저장됩니다.

>int **gsl_sf_coulomb_wave_sphF_array**(double *L_min*, int *kmax*, double *eta*, double *x*, double *fc_array*[], double *F_exponent*[])

이 함수는  :math:`L = Lmin \dots Lmin + kmax` 에 대해, 인자로 나누어진 쿨롱 함수  :math:`F_L(\eta,x)/x`  값을 계산합니다.  계산 결과값은  ``fc_array`` 배열에 저장됩니다. 오버플로우가 발생하면 지수값이  ``F_exponenet``  저장됩니다.  :math:`\eta \rightarrow 0` 이 함수는 구면 베셀 함수로 수렴합니다.

쿨롱 파동함수의 정규화 계수 (Coulomb Wave Function Normalization Constant)
-------------------------

쿨롱 파동 함수의 정규화 상수들은 Abramowitz 14.1.7에 정의되어 있습니다.

>int **gsl_sf_coulomb_CL_e**(double *L*, double *eta*, gsl_sf_result * *result*)

이 함수는  :math:`L>-1` 에 대해, 쿨롱 파동 함수의 정규화 계수  :math:`C_L (\eta)` 를 계산합니다.

>int **gsl_sf_coulomb_CL_array**(double *Lmin*, int *kmax*, double 8, double *cl*[])

이 함수는  :math:`L = Lmin \dots Lmin + kmax, Lmin > -1` 에 대해, 쿨롱 파동 함수의 정규화 계수  :math:`C_L(\eta)` 를 계산합니다.

# 상호작용 계수 (Coupling Coefficients)

위그너  :math:`3-j` ,  :math:`6-j`  그리고  :math:`9-j`  기호들은, 결합된 각 운동량 벡터들의 상호 작용 계수들을 나타냅니다. 표준 상호작용 계수 함수들의 인자가 정수거나 반-정수(half-integer)이기 때문에, 이를 계산하는 함수들의 인자들도 이와 같습니다. 이 정수들은 실제 스핀 값들의 두 배를 의미합니다.  :math:`3-j`  계수들에 대한 더 자세한 정보는 Abramowitz & Stegun, Section 27.9를 참조할 수 있습니다. 이 함수들은 헤더 파일  ``gsl_sf_coupling.h``  기술되어 있습니다.

3-j 기호(3-j Symbols)
-------------------------
> double **gsl_sf_coupling_3j**(int *two_ja*, int *two_jb*, int *two_jc*, int *two_ma*, int *two_mb*, int *two_mc*)<br>
> int **gsl_sf_coupling_3j_e**(int *two_ja*, int *two_jb*, int *two_jc*, int *two_ma*, int *two_mb*, int *two_mc*, gsl_sf_result * *result*)

이 함수들은 위그너  :math:`3-j`  계수

$$\begin{pmatrix} 
ja & jb & jc \\\\
ma & mb & mc
\end{pmatrix}, $$
를 계산합니다. 인자들은 반-정수 값을 가집니다. 예를 들어,  :math:`ja=`   ``two_ja`` /2 :math:`이고 ` ma= :math:`  ``two_ma`` /2` 입니다.

6-j 기호(6-j Symbols)
-------------------------
> double **gsl_sf_coupling_6j**(int *two_ja*, int *two_jb*, int *two_jc*, int *two_jd*, int *two_je*, int *two_jf*)<br>
> int **gsl_sf_coupling_6j_e**(int *two_ja*, int *two_jb*, int *two_jc*, int *two_jd*, int *two_je*, int *two_jf*, gsl_sf_result * *result*)

이 함수들은 위그너  :math:`6-j`  계수

$$\begin{Bmatrix} 
ja & jb & jc \\\\
jd & je & jf
\end{Bmatrix}, $$
를 계산합니다. 인자들은 반-정수 값을 가집니다. 예를 들어,  :math:`ja=`   ``two_ja`` /2 :math:`이고 ` ma= :math:`  ``two_ma`` /2` 입니다.

9-j 기호(9-j Symbols)
-------------------------
>double **gsl_sf_coupling_9j**(int *two_ja*, int *two_jb*, int *two_jc*, int *two_jd*, int *two_je*, int *two_jf*, int *two_jg*, int *two_jh*, int *two_ji*)<br>
>int **gsl_sf_coupling_9j_e**(int *two_ja*, int *two_jb*, int *two_jc*, int *two_jd*, int *two_je*, int *two_jf*, int *two_jg*, int *two_jh*, int *two_ji*, gsl_sf_result * *result*)

이 함수들은 위그너  :math:`9-j`  계수

$$\begin{Bmatrix} 
ja & jb & jc \\\\
jd & je & jf \\\\
jg & jh & ji
\end{Bmatrix}, $$
를 계산합니다. 인자들은 반-정수 값을 값을 가집니다. 예를 들어,  :math:`ja=`   ``two_ja`` /2 :math:`이고 ` ma= :math:`  ``two_ma`` /2` 입니다.

# 도슨 함수 (Dawson Function)

도슨 적분은 다음의 적분을 의미합니다.

 :math:`$D_+(x) = e^{-x^2} \int_0^x e^{t^2} \, dt` $

도슨 적분표는 Abramowitz & Stegun의 표7.5에서 찾을 수 있습니다. 이 도슨 함수는 헤더 파일  ``gsl_sf_dawson.h``  정의되어 있습니다.

> double **gsl_sf_dawson**(double *x*)<br>
> int **gsl_sf_dawson_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 주어진 값 ``x`` 대해, 도슨 적분값을 계산합니다.

# 디바이 함수 (Debye Functions)

디바이 함수  :math:`D_n(x)` 는 다음과 같이 정의됩니다.

 :math:`$D_n(x) = \frac{n}{x^n} \int_0^x \frac{t^n}{e^t -1} \, dt` $

더 자세한 정보는 Abramowitz & Stegun, Section 27.1을 참고할 수 있습니다. 디바이 함수는 헤더 파일  ``gsl_sf_debye.h``  정의되어 있습니다.

>double **gsl_sf_debye_1**(double *x*) <br>
>int **gsl_sf_debye_1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`1` 차 디바이 함수  :math:`D_1(x)` 의 값을 계산합니다.

>double **gsl_sf_debye_2**(double *x*) <br>
>int **gsl_sf_debye_2_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`2` 차 디바이 함수  :math:`D_2(x)` 의 값을 계산합니다.

>double **gsl_sf_debye_3**(double *x*) <br>
>int **gsl_sf_debye_3_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`3` 차 디바이 함수  :math:`D_3(x)` 의 값을 계산합니다.

>double **gsl_sf_debye_4**(double *x*) <br>
>int **gsl_sf_debye_4_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`4` 차 디바이 함수  :math:`D_4(x)` 의 값을 계산합니다.

>double **gsl_sf_debye_5**(double *x*) <br>
>int **gsl_sf_debye_5_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`5` 차 디바이 함수  :math:`D_5(x)` 의 값을 계산합니다.

>double **gsl_sf_debye_6**(double *x*) <br>
>int **gsl_sf_debye_6_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`6` 차 디바이 함수  :math:`D_6(x)` 의 값을 계산합니다.

# 다이로그 함수 (Dilogarithm)

다이 로그는 다음과 같이 정의됩니다.

 :math:`$Li_2 (z) = - \int_0^z \frac{\log(1-s)}{s} \, ds` $

이 함수들은 헤더 파일  ``gsl_sf_dilog.h``  정의되어 있습니다.


실수 인자 (Real Argument)
-------------------------
>double **gsl_sf_dilog**(double *x*)<br>
>int **gsl_sf_dilog_e**(double *x*, gsl_sf_result * *result*)


이 함수들은 실수 값에 대한 다이 로그값을 계산합니다. 르윈(Lewin)의 표기법으로  :math:`Li_2(x)` 로 표기되며, 이는 실수 값  :math:`x` 의 다이 로그 값을 나타냅니다. 이 값은 다음과 같이 적분형 표현으로 정의됩니다.

 :math:`$Li_2(x) = - \mathfrak{R} \int_0^x \log(1-s) /s \, ds` $
*  :math:`\mathfrak{I}(Li_2(x))` 는  :math:`x \leq 1` 에서  :math:`0` ,  :math:`x>1` 에서  :math:`- \pi \log(x)` 입니다.
* Abramowitz & Stegun에서는 스펜스 적분(Spence integral)을  :math:`Li_2(x)` 대신  :math:`S(x) = Li_2(1-x)` 로 정의합니다.


복소수 인자 (Complex Argument)
-------------------------

>int **gsl_sf_complex_dilog_e**(double *r*, double *theta*, gsl_sf_result * *result_re*, gsl_sf_result * *result_im*)

이 함수는 복소수 인자  :math:`z = r \exp(i\theta)` 에 대해, 복소수 값을 가지는 완전한 다이 로그 값을 계산합니다. 실수, 허수 값은 각각  ``result_re``   ``result_im``  반환됩니다.


# 기초 연산 (Elementary Operations)

기초 연산(Elementary Operations)
-------------------------

다음 함수들은 곱셈 과정에서 오차의 전파를 같이 계산합니다. 이 함수들은 헤더 파일  ``gsl_sf_elementary.h``  정의되어 있습니다.

>double **gsl_sf_multiply**(double *x*, double *y*) 

<br>

>int **gsl_sf_multiply_e**(double *x*, double *y*, gsl_sf_result * *result*)

이 함수는  ``x``   ``y``  곱셈을 계산하고, 계산 결과와 오차를  ``result``  저장합니다.

>int **gsl_sf_multiply_err_e**(double *x*, double *dx*, double *y*, double *dy*, gsl_sf_result * *result*)

이 함수는  ``x``   ``y``  절대 오차  ``dx``   ``dy``  함께 곱합니다.  ``result`` 는  :math:`xy \pm xy\sqrt{(dx/x)^2 + (dy/y)^2}` 가 저장됩니다.

# 타원 적분 (Elliptic Integrals)

이 단원에서 기술된 함수들은 헤더 파일  ``gsl_sf_ellint.h``  정의되어 있습니다. 타원 적분에 관한 더 자세한 정보들은 Abramowitz & Stegun, Chpater 17를 참고해 볼 수 있습니다.

르장드르 형태 정의 (Definition of Legendre Forms)
-------------------------

타원 적분의 르장드르 형태  :math:`F(\phi, k), E(\phi, k)`  그리고  :math:`\Pi(\phi, k, n)` 는 다음과 같이 정의됩니다.

 :math:`$F(\phi,k) = \int_0^{\phi} dt \frac{1}{\sqrt(1- k^2 \sin^2 (t))}` $

 :math:`$E(\phi,k) = \int_0^{\phi} dt {\sqrt(1- k^2 \sin^2 (t))}` $
 :math:`$\Pi(\phi, k, n) = \int_0^{\phi} dt \frac{1}{(1+n \sin^2(t)) \sqrt{1-k^2 \sin^2 (t)}}` $

르장드르 형태의 완전 타원 적분은  :math:`K(k) = F(\pi/2, k)` 와  :math:`E(k) = E(\pi/2, k)` 로 표기할 수 있습니다.

이 단원에서 사용하는 표기법은 Carlson, "Numerische Mathematik" 33 (1979) 1 에 기반해 있습니다. 이 표기는 Abramowitz & Stegun의 표기와 조금 다른데, 함수의 표기에서 인자  :math:`m=k^2` 이고 그리고  :math:`n` 이  :math:`-n` 으로 바뀌어 있습니다.

칼슨 형태 정의 (Definition of Carlson Forms)
-------------------------

킬슨 대칭 형태 함수  :math:`RC(x,y), RD(x,y,z), RF(x,y,z)` 와  :math:`RJ(x,y,z,p)` 

 :math:`$RC(x,y) = \frac{1}{2} \int_0^{\infty} dt \frac{1}{\sqrt{(t+x)(t+y)}}` $

 :math:`$RD(x,y,z) = \frac{3}{2} \int_0^{\infty} dt \frac{1}{\sqrt{(t+x)(t+y)} (t+z)^{\frac{3}{2}}}` $
 :math:`$RF(x,y,z) = \frac{1}{2} \int_0^{\infty} dt \frac{1}{\sqrt{(t+x)(t+y)(t+z)}}` $
 :math:`$RJ(x,y,z,p) = \frac{3}{2} \int_0^{\infty} dt \frac{1}{\sqrt{(t+x)(t+y)(t+z)} (t+p)}` $

르장드르 형태-완전 타원 적분 (Legendre Form of Complete Elliptic Integrals)
-------------------------
>double **gsl_sf_ellint_Kcomp**(double *k*, gsl_mode_t *mode*)<br>
>int **gsl_sf_ellint_Kcomp_e**(double *k*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 완전 타원 적분의 르장드르 형태  :math:`K(k)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다. Abramowitz & Stegun에서 이 함수는  :math:`m=k^2` 이라는 점에 유의해야 합니다.

>double **gsl_sf_ellint_Ecomp**(double *k*, gsl_mode_t *mode*)
>int **gsl_sf_ellint_Ecomp_e**(double *k*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 완전 타원 적분의 르장드르 형태  :math:`E(k)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다. Abramowitz & Stegun에서 이 함수는  :math:`m=k^2` 이라는 점에 유의해야 합니다.

>double **gsl_sf_ellint_Pcomp**(double *k*, double *n*, gsl_mode_t *mode*)<br>
>int **gsl_sf_ellint_Pcomp_e**(double *k*, double *n*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 완전 타원 적분의 르장드르 형태  :math:`\Pi(k, n)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다. Abramowitz & Stegun에서 이 함수는  :math:`m=k^2` 이고  :math:`\sin^2(\alpha) = k^2` 이고,  :math:`n` 의 부호를  :math:`-n` 으로 바뀌었다는 점에 유의해야 합니다.


르장드르 형태-불완전 타원 적분 (Legendre Form of Incomplete Elliptic Integrals)
-------------------------

>double **gsl_sf_ellint_F**(double *phi*, double *k*, gsl_mode_t *mode*)<br>
>int **gsl_sf_ellint_F_e**(double *phi*, double *k*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 타원 적분의 르장드르 형태  :math:`K(\phi, k)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다. Abramowitz & Stegun에서 이 함수는  :math:`m=k^2` 이라는 점에 유의해야 합니다.

>double **gsl_sf_ellint_E**(double *phi*, double *k*, gsl_mode_t *mode*)
>int **gsl_sf_ellint_E_e**(double phi, double *k*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 완전 타원 적분의 르장드르 형태  :math:`E(\phi, k)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다. Abramowitz & Stegun에서 이 함수는  :math:`m=k^2` 이라는 점에 유의해야 합니다.

>double **gsl_sf_ellint_P**(double *phi*, double *k*, double *n*, gsl_mode_t *mode*)
>int **gsl_sf_ellint_P_e**(double *phi*, double *k*, double *n*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 완전 타원 적분의 르장드르 형태  :math:`\Pi(\phi, k, n)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다. Abramowitz & Stegun에서 이 함수는  :math:`m=k^2` 이고  :math:`\sin^2(\alpha) = k^2` 이고,  :math:`n` 의 부호를  :math:`-n` 으로 바뀌었다는 점에 유의해야 합니다.

>double **gsl_sf_ellint_D**(double *phi*, double *k*, gsl_mode_t *mode*)
>int **gsl_sf_ellint_D_e**(double *phi*, double *k*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 타원 적분  :math:`D(\phi, k)` 을 계산합니다. 이 함수는 칼슨 형태 타원 함수  :math:` RD(x,y,z)` 와 다음의 관계로 정의되어 있습니다.

 :math:`$D(\phi, k) = \frac{1}{3}(\sin \phi)^3 RD(1-\sin^2(\phi), 1-k^2\sin^2(\phi),1)` $

칼슨 형태 (Carlson Forms)
-------------------------

>double **gsl_sf_ellint_RC**(double *x*, double *y*, gsl_mode_t *mode*)
>int **gsl_sf_ellint_RC_e**(double *x*, double *y*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 타원적분  :math:`RC(x, y)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다.

>double **gsl_sf_ellint_RD**(double *x*, double *y*, double *z*, gsl_mode_t *mode*)
>int **gsl_sf_ellint_RD_e**(double *x*, double *y*, double *z*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 타원적분  :math:`RD(x ,y, z)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다.

>double **gsl_sf_ellint_RF**(double *x*, double *y*, double *z*, gsl_mode_t *mode*)
>int **gsl_sf_ellint_RF_e**(double *x*, double *y*, double *z*, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 타원적분  :math:`RF(x, y, z)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다.

>double **gsl_sf_ellint_RJ**(double *x*, double *y*, double *z*, double p, gsl_mode_t *mode*)
>int **gsl_sf_ellint_RJ_e**(double *x*, double *y*, double *z*, double p, gsl_mode_t *mode*, gsl_sf_result * *result*)

이 함수들은 타원적분  :math:`RJ(x, y, z, p)` 를  ``mode`` 변수의 값에 따라 정확도를 결정해 계산합니다.

# 자코비 타원 적분 (Elliptic Functions (Jacobi))

자코비 타원 함수들은 Abramowitz & Stegun, 16 단원의 정의를 따릅니다. 이 함수들은  ``gsl_sf_elljac.h``  정의되어 있습니다.


>int **gsl_sf_elljac_e**(double *u*, double *m*, double * *sn*, double * *cn*, double * *dn*)

이 함수는 자코비 타원 함수  :math:`sn(u\|m), cn(u\|m) , dn(u\|m)` 을 내림차순 란덴 변환을 이용해 계산합니다.

# 오차 함수 (Error Functions)

오차 함수는 Abramowitz & Stegun, Chapter 7.에 기술되어 있습니다. 이 단원에서 기술된 함수들은 헤더파일  ``gs_sf_erf.h``  기술되어 있습니다.

오차 함수(Error Functionn)
-------------------------

>double **gsl_sf_erf**(double *x*)<br>
>int **gsl_sf_erf_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 오차함수  :math:`\text{erf}(x)` 의 값을 계산합니다.  :math:`\text{erf}(x)` 는 다음과 같이 정의됩니다.

 :math:`$\text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x dt \exp(-t^2)` $

상보 오차 함수(Complementary Error Functionn)
-------------------------

>double **gsl_sf_erfc**(double *x*)<br>
>int **gsl_sf_erfc_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 상보 오차 함수  :math:`\text{erfc}(x) = 1- \text{erf}(x)` 의 값을 계산합니다.  :math:`\text{erfc}(x)` 는 다음과 같이 정의됩니다.

 :math:`$\text{erfc}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty dt \exp(-t^2)` $

로그 상보 오차 함수(Log Complementary Error Functionn)
-------------------------

>double **gsl_sf_log_erfc**(double *x*)<br>
>int **gsl_sf_log_erfc_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 상보 오차 함수의 로그값  :math:`\log(\text{erfc}(x))` 를 계산합니다.


확률 함수 (Probability functions)
-------------------------

표준/가우스 분포의 확률 함수들은 Abramowitz & Stegun, Section 26.2에 기술되어 있습니다.

>double **gsl_sf_erf_Z**(double *x*)<br>
>int **gsl_sf_erf_Z_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 가우스 확률 밀도 함수  :math:`Z(x) = \frac{1}{\sqrt{2\pi}} \exp(- \frac{x^2}{2})` 의 값을 계산합니다.


>double **gsl_sf_erf_Q**(double *x*)<br>
>int **gsl_sf_erf_Q_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 가우스 확률 함수의 


표준 분포의 하자드 함수(Hazard function)는 Mills' 비의 역으로도 알려져 있습니다. 이는 다음과 같이 정의됩니다.

 :math:`$h(x) = \frac{Z(x)}{Q(x)} = \sqrt{\frac{2}{\pi}} \frac{\exp(- x^2/2)}{\text{erfc}(x/\sqrt{2})}` $

이 함수는  :math:`x` 가  :math:`-\infty` 에 가까우질 수록 급격히 감소하며,  :math:`x` 가  :math:`+\infty` 에 가까워질 수록  :math:`h(x) \approx` 로 점근합니다.

>double **gsl_sf_hazard**(double *x*)<br>
>int **gsl_sf_hazard_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 표준 분포의 하자드 함수(Hazard function)를 계산합니다.


# 지수 함수 (Exponential Functions)

이 단원에서 기술하는 함수들은 헤더 파일  ``gsl_sf_exp.h``  정의되어 있습니다.

지수 함수 (Exponential Function)
-------------------------

> double **gsl_sf_exp**(double *x*) <br>
> int **gsl_sf_exp_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 지수 함수  :math:`\exp(x)` 의 값을 계산합니다. 이 함수들은 GSL semantics와 오차 검사를 함께 진행합니다.

>int **gsl_sf_exp_e10_e**(double *x*, gsl_sf_result_e10 * *result*)

이 함수는 지수 함수  :math:`\exp(x)` 의 값을 계산하는 데, 반환값의 자료형으로 ``gsl_sf_result_e10``  사용해 확장된 크기의 반환값을 계산합니다. 이 함수는  ``double`` 자료형의 범주를 초과한  :math:`\exp(x)` 값을 구할 때, 사용할 수 있습니다.

> double **gsl_sf_exp_mult**(double *x*, double *y*)<br>
> int **gsl_sf_exp_mult_e**(double *x*, double *y*, gsl_sf_result * *result*)

이 함수들은 주어진 실수  ``x``  지수 함수 값에 계수  ``y``  곱한 값  :math:`y \exp(x)` 를 계산합니다.

>int **gsl_sf_exp_mult_e10_e**(const double *x*, const double *y*, gsl_sf_result_e10 * *result*)

이 함수는 확장된 범위를 가지는  ``gsl_sf_result_e10`` 자료형을 반환 값에 사용해  :math:`y \exp(x)`  값을 계산합니다.

상대 지수 함수 (Relative Exponential Functions)
-------------------------

> double **gsl_sf_expm1**(double *x*)<br>
> int **gsl_sf_expm1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`\exp(x)-1` 를 계산합니다. 이 함수에 사용된 알고리즘은 작은  :math:`x` 에서만 정확합니다.

> double **gsl_sf_exprel**(double *x*)<br>
> int **gsl_sf_exprel_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 작은  :math:`x`  값에서 정확한 알고리즘을 이용해  :math:`(\exp(x)-1) /x` 값을 계산합니다. 작은  :math:`x`  값에 대해, 알고리즘은 다음과 같은 확장을 이용합니다.

 :math:`$(\exp(x)-1) /x = 1 + x/2 + x^2/(2 \cdot 3) + x^3/(2 \cdot 3 \cdot 4) + \dots` $ 

> double **gsl_sf_exprel_2**(double *x*)<br>
> int **gsl_sf_exprel_2_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 작은  :math:`x`  값에서 정확한 알고리즘을 이용해  :math:`2(\exp(x)-1 -x) /x^2` 값을 계산합니다. 작은  :math:`x`  값에 대해, 알고리즘은 다음과 같은 확장을 이용합니다.

 :math:`$2(\exp(x)-1 -x) /x^2 = 1 + x/3 + x^2/(3 \cdot 4) + x^3/(3 \cdot 4 \cdot 5) + \dots` $ 


> double **gsl_sf_exprel_n**(int *n*, double *x*)<br>
> int **gsl_sf_exprel_n_e**(int *n*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`N-`  상대 지수 함수 값을 계산합니다. 이 함수는  ``gsl_sf_exprel()``   ``gsl_sf_exprel_2()`` 수의  ``n`` 째 일반화 함수입니다. 이 함수는 다음과 같이 주어집니다.

$$\begin{flalign}
\text{exprel}\_N (x) &= N!/x^N (\exp(x) - \sum\_{k=0}^{N-1} x^k/k!) \\\\ 
&= 1+x/(N+1) + x^2/((N+1)(N+2)) + \dots \\\\
&=  {}\_1F\_1(1,1+N,x)
\end{flalign}$$ 

오차 평가가 있는 지수 함수 (Exponentiation With Error Estimate)
-------------------------

> int **gsl_sf_exp_err_e**(double *x*, double *dx*, gsl_sf_result * *result*)

이 함수는 주어진  ``x``  지수함수 값을 절대 오차  ``dx``  함께 반환합니다.

> int **gsl_sf_exp_err_e10_e**(double *x*, double *dx*, gsl_sf_result_e10 * *result*)

이 함수는 주어진  ``x``  지수함수 값을 절대 오차  ``dx``  함께 반환합니다. 이때, 반환 값의 자료형을  ``gsl_sf_result_e10`` 을 사용해 확장된 범위의 결과를 계산할 수 있습니다.

> int **gsl_sf_exp_mult_err_e**(double *x*, double *dx*, double *y*, double *dy*, gsl_sf_result * *result*)

이 함수는  ``x``  ``y``  대해,  :math:`y \exp(x)` 값을 절대 오차  ``dx``  ``dy``  함께 계산합니다.

>int **gsl_sf_exp_mult_err_e10_e**(double *x*, double *dx*, double *y*, double *dy*, gsl_sf_result_e10 * *result*)

이 함수는  ``x``  ``y``  대해,  :math:`y \exp(x)` 값을 절대 오차  ``dx``  ``dy``  함께 계산합니다. 이때, 반환 값의 자료형을  ``gsl_sf_result_e10`` 을 사용해 확장된 범위의 결과를 계산할 수 있습니다.

# 지수 적분 함수 (Exponential Integrals)


지수 적분의 자세한 정보는 Abramowitz & Stegun, Chapter 5. 에서 찾아볼 수 있습니다. 이 함수들은 헤더 파일  ``gsl_sf_expint.h``  정의되어 있습니다.

지수 적분 (Exponential Integral)
-------------------------

>double gsl_sf_expint_E1(double *x*) <br>
>int gsl_sf_expint_E1_e(double *x*, gsl_sf_result * *result*)

이 함수들은 지수 적분 함수  :math:`E_1(x)` 를 계산합니다.

 :math:`$E_1(x) := \mathfrak{R} \int_1^\infty \frac{\exp(-xt)}{t}  dt` $


>double gsl_sf_expint_E2(double *x*)<br>
>int gsl_sf_expint_E2_e(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`2` 차 지수 적분 함수  :math:`E_2(x)` 를 계산합니다.

 :math:`$E_2(x) := \mathfrak{R} \int_1^\infty \frac{\exp(-xt)}{t^2}  dt` $

>double gsl_sf_expint_En(int *n*, double *x*)<br>
>int gsl_sf_expint_En_e(int *n*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`n` 차 지수 적분 함수  :math:`E_2(x)` 를 계산합니다.

 :math:`$E_n(x) := \mathfrak{R} \int_1^\infty \frac{\exp(-xt)}{t^n}  dt` $


 :math:`Ei(x)` 
-------------------------

>double gsl_sf_expint_Ei(double *x*)<br>
>int gsl_sf_expint_Ei_e(double *x*, gsl_sf_result * *result*)

이 함수는 지수 적분  :math:`Ei(x)` 의 값을 계산합니다.

 :math:`$Ei(x) = - PV (\int_{-x}^\infty \frac{\exp(-t)}{t} dt)` $

 :math:`PV` 는 적분 주요값(Principal Value of Integral)입니다. 코시 주요값(Cauchy principal value)이라고도 합니다(\*).

초기하 적분 (Hyperbolic Integrals)
-------------------------

>double gsl_sf_Shi(double *x*)<br>
>int gsl_sf_Shi_e(double *x*, gsl_sf_result * *result*)

이 함수들은 다음의 적분값을 계산합니다.

 :math:`$\text{Shi} (x) := \int_0^x \frac{\sinh(t)}{t} dt` $


>double gsl_sf_Chi(double *x*)<br>
>int gsl_sf_Chi_e(double *x*, gsl_sf_result * *result*)

이 함수들는 다음의 적분값을 계싼합니다.

 :math:`$\text{Chi}(x) := \mathfrak{R} [\gamma_E + \log(x) + \int_0^x \frac{\cosh(t) -1}{t} dt]` $

 :math:`\gamma_E` 는 오일러 상수입니다.  ``M_EULER`` 매크로로 라이브러리 내에 있습니다.


 :math:`Ei_3(x)` 
-------------------------

>double gsl_sf_expint_3(double *x*)<br>
>int gsl_sf_expint_3_e(double *x*, gsl_sf_result * *result*)

이 함수들은 다음의  :math:`3` 차 지수 적분값을  :math:`x \geq 0` 에 대해 계산합니다.

 :math:`$\text{Ei}_3 (x) := \int_0^x \exp(-t^3) dt` $

삼각 적분 (Trigonometric Integrals)
-------------------------

>double gsl_sf_Si(const double *x*)<br>
>int gsl_sf_Si_e(double *x*, gsl_sf_result * *result*)

이 함수들은 다음의 적분값을 계산합니다.

 :math:`$\text{Si} (x) := \int_0^x \frac{\sin(t)}{t} dt` $

>double gsl_sf_Ci(const double *x*)<br>
>int gsl_sf_Ci_e(double *x*, gsl_sf_result * *result*)

이 함수들은 다음의 적분값을  :math:`x \geq 0` 에 대해 계산합니다.

 :math:`$\text{Ci} (x) := -\int_0^x \frac{\cos(t)}{t} dt` $

역탄젠트 적분 (Arctangent Integral)
-------------------------


>double gsl_sf_atanint(double *x*)<br>
>int gsl_sf_atanint_e(double *x*, gsl_sf_result * *result*)

이 함수들은 다음의 적분값을 계산합니다.

 :math:`$\text{AtanInt}(x) := \int_0^x \frac{\text{arctan}}{t} dt` $

# 페르미 디렉 함수 (Fermi-Dirac Function)


이 함수들은 헤더 파일  ``gsl_sf_fermi_dirac.h``  정의되어 있습니다.

완비 페르미-디렉 적분 (Complete Fermi-Dirac Integrals)
-------------------------

완비 페르미 디렉 적분  :math:`F_j(x)` 는 다음과 같이 정의됩니다.

 :math:`$F_j(x) := \frac{1}{\Gamma(j+1)} \int_0^\infty \frac{t^j}{(\exp(t-x)+1)} dt` $

다른 문헌에서 정규화 계수 없이 표현되기도 합니다.

>double **gsl_sf_fermi_dirac_m1**(double *x*)<br>
>int **gsl_sf_fermi_dirac_m1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`j=-1` 인 완비 페르미 디렉 적분 값을 계산합니다. 이 값은  :math:`F_{-1}(x) = e^x/(1+e^x)` 로 주어집니다.

>double **gsl_sf_fermi_dirac_0**(double *x*)<br>
>int **gsl_sf_fermi_dirac_0_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`j=0` 인 완비 페르미 디렉 적분 값을 계산합니다. 이 값은  :math:`F_{0}(x) = \ln(1+e^x)` 로 주어집니다.

>double **gsl_sf_fermi_dirac_1**(double *x*)<br>
>int **gsl_sf_fermi_dirac_1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`j=-1` 인 완비 페르미 디렉 적분 값을 계산합니다. 이 값은  :math:`F_{1}(x) = \int_0^\infty(t / (\exp(t-x)+1) dt` 로 주어집니다.

>double **gsl_sf_fermi_dirac_2**(double *x*)<br>
>int **gsl_sf_fermi_dirac_2_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`j=2` 인 완비 페르미 디렉 적분 값을 계산합니다. 이 값은  :math:`F_{2}(x) = (1/2) \int_0^\infty(t^2 / (\exp(t-x)+1) dt` 로 주어집니다.

>double **gsl_sf_fermi_dirac_int**(int *j*, double *x*)<br>
>int gsl_sf_fermi_dirac_int_e(int *j*, double *x*, gsl_sf_result * *result*)

이 함수들은 일반 완비 페르미 디렉 적분 값을 계산합니다. 이 값은  :math:`F_{j}(x) = ((1/\Gamma(j+1)) \int_0^\infty (t^j / (\exp(t-x)+1) dt` 로 주어집니다.


>double **gsl_sf_fermi_dirac_mhalf**(double *x*)<br>
>int **gsl_sf_fermi_dirac_mhalf_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 완비 페르미-디렉 적분  :math:`F_{-1/2}(x)`  값을 계산합니다.

>double **gsl_sf_fermi_dirac_half**(double *x*)<br>
>int **gsl_sf_fermi_dirac_half_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 완비 페르미-디렉 적분  :math:`F_{1/2}(x)`  값을 계산합니다.


>double **gsl_sf_fermi_dirac_3half**(double *x*)<br>
>int **gsl_sf_fermi_dirac_3half_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 완비 페르미-디렉 적분  :math:`F_{3/2}(x)`  값을 계산합니다.

비완비 페르미-디렉 적분 (Incomplete Fermi-Dirac Integrals)
-------------------------

비완비 페르미-디렉 함수  :math:`F_j(x,b)` 는 다음과 같이 정의됩니다.

 :math:`$ F_j(x,b) := \frac{1}{\Gamma (j+1)} \int_b^\infty \frac{t^j}{\exp(t-x)+1} dt` $

>double **gsl_sf_fermi_dirac_inc_0**(double *x*, double *b*)<br>
>int **gsl_sf_fermi_dirac_inc_0_e**(double *x*, double *b*, gsl_sf_result * *result*)

이 함수들은  :math:`0`  차수의 비완비 페르미-디렉 적분,  :math:`F_) (x,b) = \ln (1+ e^{b-x}) - (b-x)` 값을 계산합니다.

# 감마, 베타 함수 (Gamma and Beta Functions)

다음 함수들은 완전/불완전 감마, 베타 함수를 다양한 팩토리얼에 대해, 계산합니다. 이 단원의 함수들은 헤더 파일  ``gsl_sf_gamma.h``  정의되어 있습니다.

 감마 함수 (Gamma Functions)
-------------------------

감마 함수는 다음의 적분으로 정의되어 있습니다.

 :math:`$\Gamma (x) = \int_0^\infty t^{x-1} \exp(-t) dt` $

양의 정수  :math:`n` 에 대해, 이 함수는 팩토리얼과  :math:`\Gamma (n) = (n-1)!` 의 관계를 가집니다. 감마 함수에 관한 더 자세한 설명은 Abramowitz & Stegun, Chapter 6를 참조할 수 있습니다.

>double **gsl_sf_gamma**(double *x*)<br>
>int **gsl_sf_gamma_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`0` 이나 음의 정수가 아닌  :math:`x` 에 대해, 감마 함수  :math:`\Gamma(x)` 의 값을 계산합니다. 이 함수는 실수 Lanczos 방법을 사용합니다.  :math:`x` 의 최댓값은  :math:`\Gamma(x)` 가 오버 플로우 되지 않는 범위로 매크로  ``GSL_SF_GAMMA_XMAX``  주어져 있습니다. 이 값은  :math:`171.0` 입니다.

>double **gsl_sf_lngamma**(double *x*)<br>
>int **gsl_sf_lngamma_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`0` 이나 음의 정수가 아닌  :math:`x` 에 대해, 로그 감마 함수  :math:`\log(\Gamma(x))` 의 값을 계산합니다.  :math:`x<0` 에 대해,  :math:`\log(\Gamma(x))` 값이 반환되며, 이 값은  :math:`\log(|\Gamma(x)|)` 의 값과 같습니다. 이 함수는 실수 Lanczos 방법을 사용합니다.

>int **gsl_sf_lngamma_sgn_e**(double *x*, gsl_sf_result * *result_lg*, double * *sgn*)

이 함수는  :math:`0` 이나 음의 정수가 아닌  :math:`x` 에 대해, 감마 함수의 부호와 그 크기의 로그 값을 계산합니다. 이 함수는 실수 Lanczos 방법을 사용합니다. 감마 함수의 값과 그 오차는  ``result_lg``  두 요소와 다음의 관계를 사용해 계산합니다.  :math:`\Gamma(x) = sgn * \exp(result_lg)` .

>double **gsl_sf_gammastar**(double *x*)<br>
>int **gsl_sf_gammastar_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 regulated 감마 함수  :math:`\Gamma^* (x)` 를  :math:`x>0` 에 대해 계산합니다. 이 함수는 다음과 같이 주어집니다.

 :math:`$\Gamma^* (x) = \Gamma (x)/(\sqrt{2 \pi}x^{(x-1/2)} \exp(-x))` $
 :math:`$= (1+ \frac{1}{12x}+ \dots) \text{ for } x \rightarrow \infty` $

>double **gsl_sf_gammainv**(double *x*)<br>
>int **gsl_sf_gammainv_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 실수 Lanczos 방법을 사용해 감마 함수의 역수,  :math:`1/\Gamma(x)`  값을 계산합니다.

>int **gsl_sf_lngamma_complex_e**(double *zr*, double *zi*, gsl_sf_result * *lnr*, gsl_sf_result * *arg*)

이 함수는 복소수 Lanczos 방법을 사용해, 주어진 복소수  :math:`z= z_r + i z_i` 에 대해,  :math:`\log(\Gamma(z))`  값을 계산합니다. 이때,  :math:`z` 는  :math:`0` 과 음의 정수가 아닌 복소수입니다.  :math:`lnr = \log|\Gamma(z)|` ,  :math:`arg = \text{arg}(\Gamma(z))` 이고,  :math:`arg` 는  :math:`(-\pi, \pi]`  범위의 값을 가집니다.  :math:`|z|` 가 매우 클 때,  ``arg`` 값이 정확히 정해지지 않을 수 있습니다. 이는  :math:`(-\pi, \pi]` 로 범위를 제약함으로써 필연적으로 생기는 절단점으로 인해 생깁니다. 이러한 상황은  ``GSL_ELOSS`` 오류에 속하는 상황입니다. 절대값  ``lnr`` 부분은 이러한 정밀도 저하를 격지 않습니다.

팩토리얼
-------------------------

양의 정수  :math:`n` 에 대해, 감마 함수를 이용해  :math:`n! = \Gamma(n+1)`  팩토리얼을  계산할 수 있습니다. 하지만, 아래의 함수들을 이용하는 것이 작은  :math:`n`  값들에 대해 더 효율적입니다. 이 함수들은 팩토리얼 값들을 하드 코딩된 테이블에 보관하고 있습니다.

>double **gsl_sf_fact**(unsigned int *n*)<br>
>int **gsl_sf_fact_e**(unsigned int *n*, gsl_sf_result * *result*)

이 함수들은 팩토리얼  :math:`n!` 를 계산합니다. 팩토리얼은 감마 함수와  :math:`n! = \Gamma(n+1)` 의 관계를 가지고 있습니다.  :math:`n` 의 최댓값은  :math:`n!` 이 오버플로우되지 않는 값으로 정해집니다. 이는 매크로  ``GSL_SF_FACT_NMAX``  정의되어 있고  :math:`170` 입니다.

>double **gsl_sf_doublefact**(unsigned int *n*)<br>
>int **gsl_sf_doublefact_e**(unsigned int *n*, gsl_sf_result * *result*)

이 함수들은 더블 팩토리얼  :math:`n!! = n(n-2)(n-4)\dots` 을 계산합니다.  :math:`n` 의 최댓값은  :math:`n!!` 이 오버플로 되지 않는 값으로 정해집니다. 이는 매크로  ``GSL_SF_DOUBLEFACT_NMAX``  정의되어 있고  :math:`297` 입니다.

>double **gsl_sf_lnfact**(unsigned int *n*)<br>
>int **gsl_sf_lnfact_e**(unsigned int *n*, gsl_sf_result * *result*)

이 함수들은  ``n`` 팩토리얼의 로그 값,  :math:`\log(n!)`  값을 계산합니다. 이 알고리즘은  :math:`n <170` 에서  :math:`\ln(\Gamma(n+1))`  값을 계산하는  ``gsl_sf_lngamma`` 다 빠릅니다. 하지만 큰  ``n``  대해서는 빠르지 않습니다.

>double **gsl_sf_lndoublefact**(unsigned int *n*)<br>
>int **gsl_sf_lndoublefact_e**(unsigned int *n*, gsl_sf_result * *result*)

이 함수들은  ``n``  대해, 더블 팩토리얼의 로그 값  :math:`\log(n!!)` 을 계산합니다.

>double **gsl_sf_choose**(unsigned int *n*, unsigned int *m*)<br>
>int **gsl_sf_choose_e**(unsigned int *n*, unsigned int *m*, gsl_sf_result * *result*)

이 함수들은 조합 계수  ``n choose m``  :math:`= n!/(m!(n-m!))` 의 값을 계산합니다.

>double **gsl_sf_lnchoose**(unsigned int *n*, unsigned int *m*)<br>
>int **gsl_sf_lnchoose_e**(unsigned int *n*, unsigned int *m*, gsl_sf_result * *result*)

이 함수들은 조합 계수  ``n choose m``  로그 값을 계산합니다. 이 값은  :math:`\log(n!) - \log(m!) - \log((n-m)!)` 과 같습니다.

>double **gsl_sf_taylorcoeff**(int *n*, double *x*)<br>
>int **gsl_sf_taylorcoeff_e**(int *n*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x \geq0` ,  :math:`n \geq0` 에 대해, 테일러 계수  :math:`x^n/n!` 값을 계산합니다.

포흐하머 기호
-------------------------

>double **gsl_sf_poch**(double *a*, double *x*)<br>
>int **gsl_sf_poch_e**(double *a*, double *x*, gsl_sf_result * *result*)

이 함수들은 포흐하머 기호  :math:`(a)_x = \Gamma(a_x)/\Gamma(a)` 를 계산합니다. 포흐하머 기호는 아펠(Apell) 기호로도 알려져있으며,  :math:`(a,x)` 로 표기하기도 합니다.  :math:`a` 와  :math:`a+x` 가 음의 정수나  :math:`0` 일때, 해당 비의 극한 값이 반환됩니다.

>double **gsl_sf_lnpoch**(double *a*, double *x*)<br>
>int **gsl_sf_lnpoch_e**(double *a*, double *x*, gsl_sf_result * *result*)

이 함수들은 포흐하머 기호의ㅣ 로그값  :math:`\log((a)_x) = \log(\Gamma(a+x)/\Gamma(a))` 을 계산합니다.

>int **gsl_sf_lnpoch_sgn_e**(double *a*, double *x*, gsl_sf_result * *result*, double * *sgn*)

이 함수들은 포흐하머 기호의 부호와 그 크기의 로그값을 계산합니다. 계산되는 계수들은  :math:`result = \log(|(a)_x|)` 가 오차 값과 함께 계산되고,  :math:`(a)_x = \Gamma(a+x)/\Gamma(a)` 에 대해,  :math:`sgn = \text{sgn})(a)_x)` 을 계산합니다.


>double **gsl_sf_pochrel**(double *a*, double *x*)<br>
>int **gsl_sf_pochrel_e**(double *a*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`(a)_x = \Gamma(a+x)/\Gamma(a)` 에 대해,  :math:`((a)_x -1)/x` 값을 계산합니다.

불완전 감마 함수
-------------------------

>double **gsl_sf_gamma_inc**(double *a*, double *x*)<br>
>int **gsl_sf_gamma_inc_e**(double *a*, double *x*, gsl_sf_result * *result*)

이 함수들은 실수  :math:`a` 와  :math:`x \geq 0` 에 대해, 비정규화된 불완전 감마 함수  :math:`\Gamma(a,x) = \int_x^\infty t^{(a-1)} \exp(-t) dt`  값을 계산합니다.

>double **gsl_sf_gamma_inc_Q**(double *a*, double *x*)<br>
>int **gsl_sf_gamma_inc_Q_e**(double *a*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`a>0` 과  :math:`x \leq 0` 에 대해, 정규화된 불완전 감마 함수  :math:`Q(a,x) = 1.\Gamma(a) \int_x^\infty t^{(a-1)} \exp(-t) dt` 의 값을 계산합니다.

>double **gsl_sf_gamma_inc_P**(double *a*, double *x*)<br>
>int **gsl_sf_gamma_inc_P_e**(double *a*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`a>0` 과  :math:`x \geq 0` 에 대해,  :math:`P(a,x) = 1-Q(a,x) = 1/\Gamma(a) \int_0^x t^{(a-1)} \exp(-t) dt` 값을 계산합니다.

Abramowtz & Stegun의 6.5단원, 불완전 감마 함수에서  :math:`P(a,x)`  표기를 씁니다. 
베타 함수
-------------------------


>double **gsl_sf_beta**(double *a*, double *b*)<br>
>int **gsl_sf_beta_e**(double *a*, double *b*, gsl_sf_result * *result*)

이 함수들은 베타함수  :math:`B(a,b) = \Gamma(a)\Gamma(b)/\Gamma(a+b)`  값을 계산합니다.  :math:`a,b` 는 음의 정수가 아니여야 합니다.

>double **gsl_sf_lnbeta**(double *a*, double *b*)<br>
>int **gsl_sf_lnbeta_e**(double *a*, double *b*, gsl_sf_result * *result*)

이 함수들은 베타 함수의 로그 값  :math:`\log(B(a,b))` 를 계산합니다.  :math:`a,b` 는 음의 정수가 아니여야 합니다.

불완전 베타 함수
-------------------------

>double **gsl_sf_beta_inc**(double *a*, double *b*, double *x*)<br>
>int **gsl_sf_beta_inc_e**(double *a*, double *b*, double *x*, gsl_sf_result * *result*)

이 함수들은 정규화된 불완전 베타함수  :math:`I_x (a,b) = B_x(a,b)/ B(a,b)` 를 계산합니다.  :math:`B_x(a,b)` 는  :math:`0 \leq x \leq 1` 에 대해 다음과 같이 정해집니다.

 :math:`$ B_x (a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt` $

이 값은  :math:`a>0, b>0` 에 대해, 연속 분수 전개를 이용해 계산됩니다. 다른 경우에는 다음의 관계를 이용해 계산합니다.

 :math:`$I_x (a,b,x) = (\frac{1}{a}) x^a \frac{_2F_1 (a, 1-b, a+1, x)}{B(a,b)}` $


# 구겐바우어 함수 (Gegenbauer Functions)

구겐바우어 다항식은 Abramowitz & Stgun의 22단원에 정의되어 있습니다. 이 다항식은 또 Ultraspherical 다항식으로도 알려져있습니다. 이 함수들은 헤더 파일  ``gsl_sf_gegenbauer.h``  정의되어 있습니다.

>double **gsl_sf_gegenpoly_1**(double *lambda*, double *x*) <br>
>double **gsl_sf_gegenpoly_2**(double *lambda*, double *x*) <br>
>double **gsl_sf_gegenpoly_3**(double *lambda*, double *x*) <br>
>int **gsl_sf_gegenpoly_1_e**(double *lambda*, double *x*, gsl_sf_result * *result*) <br>
>int **gsl_sf_gegenpoly_2_e**(double *lambda*, double *x*, gsl_sf_result * *result*) <br>
>int **gsl_sf_gegenpoly_3_e**(double *lambda*, double *x*, gsl_sf_result * *result*) 

이 함수들은 구겐바우어 다항식  :math:`C_n^{(\lambda)}(x)` 을  :math:`n= 1, 2, 3` 인 경우에 대해, 정의식을 이용해 계산합니다.


>double **gsl_sf_gegenpoly_n**(int *n*, double *lambda*, double *x*) <br>
>int **gsl_sf_gegenpoly_n_e**(int *n*, double *lambda*, double *x*, gsl_sf_result * *result*)

이 함수들은 구겐바우어 다항식  :math:`C_n^{(\lambda)}(x)` 을 주어진  ``n``  ``lambda``   ``x``  대해 계산합니다. 이때,  :math:`\lambda > - \frac{1}{2}. n \geq 0` 이어야 합니다.


> int **gsl_sf_gegenpoly_array**(int *nmax*, double *lambda*, double *x*, double *result_array*[])

이 함수는 구겐바우어 다항식 :math:`C_n^{(\lambda)}(x)`  배열 값을 계산합니다.  :math:`n = 0, 1, 2, \dots , nmax` 의 값을 계산하며,  :math:`\lambda > - \frac{1}{2}. nmax \geq 0` 의 제약을 가집니다.


# 에르미트 다항식과 함수 (Hermite Polynomials and Functions)

에르미트 다항식과 함수는 Abramowitz & Stegunm Chapter 22 와 Szego, Gabor (1939, 1957, 1967) Orthogonal Polynomials, American Mathematical Society에 기술되어 있습니다. 본 단원의 함수들은 헤더 파일  ``gsl_sf_hermite.h``  정의 되었습니다.

에르미트 다항식(Hermite Polynomials)
-------------------------

에르미트 다항식은 두 가지 형태가 존재합니다.  :math:`H_n(x)` 는 물리학에서 사용하는 형태이고,  :math:`H_{e_n}(x)` 는 확률론에서 사용하는 형태입니다. 

 :math:`$H_n(x) = (-1)^n e^{x^2} (\frac{d}{dx})^n e^{-x^2}` $
 :math:`$H_{e_n}(x) = (-1)^n e^{x^2/2} (\frac{d}{dx})^n e^{-x^2/2}` $

이 둘은 다음의 관계를 가지고,

 :math:`$H_n(x) = 2^{\frac{n}{2}}H_{e_n}(\sqrt{2}x)` $
 :math:`$H_{e_n}(x) = 2^{-\frac{n}{2}}H_n(\frac{x}{\sqrt{2}})` $

다음과 같은 미분 방정식을 만족합니다.

 :math:`$H_{n}''(x) -2xH_{n}'(x) + 2nH_{n}(x)=0` $
 :math:`$H_{e_n}''(x) -xH_{e_n}'(x) + nH_{e_n}(x)=0` $

>double **gsl_sf_hermite**(const int *n*, const double *x*)<br>
>int **gsl_sf_hermite_e**(const int *n*, const double *x*, gsl_sf_result * *result*)

이 함수는  :math:`H_n(x)`  형태의 에르미트 다항식을 주어진 차수  ``n``  변수  ``x``  대해 계산합니다. 오버플로우가 감지되면, 오류 관리자를 호출하지 않고  ``GSL_EOVERFLW``  반환합니다.

>int **gsl_sf_hermite_array**(const int *nmax*, const double *x*, double * *result_array*)

이 함수는  ``nmax`` 이하의 차수를 가지는 모든  :math:`H_n(x)`  형태의 에르미트 다항식을 주어진 변수  ``x``  대해 계산합니다. 결과는  ``result_array``  저장됩니다.

>double **gsl_sf_hermite_series**(const int *n*, const double *x*, const double * *a*)<br>
>int **gsl_sf_hermite_series_e**(const int *n*, const double *x*, const double * *a*, gsl_sf_result * *result*)

이 함수들은  :math:`\sum_{j=0}^n a_j H_j (x)`  급수 값을 Clenshaw 알고리즘을 이용해 계산합니다.

>double **gsl_sf_hermite_prob**(const int *n*, const double *x*)<br>
>int **gsl_sf_hermite_prob_e**(const int *n*, const double *x*, gsl_sf_result * *result*)

이 함수는   :math:`H_{e_n}(x)`  형태의 에르미트 다항식을 주어진 차수  ``n``  변수  ``x``  대해 계산합니다. 오버플로우가 감지되면, 오류 관리자를 호출하지 않고  ``GSL_EOVERFLW``  반환합니다.

>int **gsl_sf_hermite_prob_array**(const int *nmax*, const double *x*, double * *result_array*)

이 함수는  ``nmax`` 이하의 차수를 가지는 모든  :math:`H_{e_n}(x)`  형태의 에르미트 다항식을 주어진 변수  ``x``  대해 계산합니다. 결과는  ``result_array``  저장됩니다.


>double **gsl_sf_hermite_prob_series**(const int *n*, const double *x*, const double * *a*)<br>
>int **gsl_sf_hermite_prob_series_e**(const int *n*, const double *x*, const double * *a*, gsl_sf_result * *result*)

이 함수들은  :math:`\sum_{j=0}^n a_j H_{e_j} (x)`  급수 값을 Clenshaw 알고리즘을 이용해 계산합니다.


에르미트 다항식의 도함수 (Derivatives of Hermite Polynomials)
-------------------------

>double **gsl_sf_hermite_deriv**(const int *m*, const int *n*, const double *x*)<br>
>int gsl_sf_hermite_deriv_e(const int *m*, const int *n*, const double *x*, gsl_sf_result * *result*)

이 함수들은  ``n`` 차수의 에르미트 다항식  :math:`H_n(x)` 의  ``m``  도함수 값을 주어진 변수 ``x``  대해 계산합니다.

>int **gsl_sf_hermite_array_deriv**(const int *m*, const int *nmax*, const double *x*, double * *result_array*)

 이 함수는  :math:`0, \dots, nmax`  차수의 모든 에르미트 다항식  :math:`H_n(x)` 의  ``m``  도함수 값을 주어진 변수  ``x``  대해 계산합니다.   :math:`d^m / dx^m H_n(x)` 의 값은  ``result_array[n]``  저장됩니다. 계산 결과가 저장되는  ``result_array``  최소  ``nmax+1`` 이상의 길이를 가져야 합니다.

>int **gsl_sf_hermite_deriv_array**(const int *mmax*, const int *n*, const double *x*, double * *result_array*)

 이 함수는  ``n``  차수를 가지는 에르미트 다항식  :math:`H_n(x)` 의 모든  :math:`0, \dots, mmax` 차 도함수 값을 주어진 변수  ``x``  대해 계산합니다.   :math:`d^m / dx^m H_n(x)` 의 값은  ``result_array[m]]``  저장됩니다. 계산 결과가 저장되는  ``result_array``  최소  ``mmax+1`` 이상의 길이를 가져야 합니다.


>double **gsl_sf_hermite_prob_deriv**(const int *m*, const int *n*, const double *x*)<br>
>int **gsl_sf_hermite_prob_deriv_e**(const int *m*, const int *n*, const double *x*, gsl_sf_result * *result*)

이 함수들은  ``n`` 차수의 에르미트 다항식  :math:`H_{e_n}(x)` 의  ``m``  도함수 값을 주어진 변수 ``x``  대해 계산합니다.

>int **gsl_sf_hermite_prob_array_deriv**(const int *m*, const int *nmax*, const double *x*, double * *result_array*)

 이 함수는  ``n``  차수를 가지는 에르미트 다항식  :math:`H_{e_n}(x)` 의 모든  :math:`0, \dots, mmax` 차 도함수 값을 주어진 변수  ``x``  대해 계산합니다.   :math:`d^m / dx^m H_{e_n}(x)` 의 값은  ``result_array[m]]``  저장됩니다. 계산 결과가 저장되는  ``result_array``  최소  ``mmax+1`` 이상의 길이를 가져야 합니다.



>int **gsl_sf_hermite_prob_deriv_array**(const int *mmax*, const int *n*, const double *x*, double * *result_array*)

 이 함수는  ``n``  차수를 가지는 에르미트 다항식  :math:`H_{e_n}(x)` 의 모든  :math:`0, \dots, mmax` 차 도함수 값을 주어진 변수  ``x``  대해 계산합니다.   :math:`d^m / dx^m H_{e_n}(x)` 의 값은  ``result_array[m]]``  저장됩니다. 계산 결과가 저장되는  ``result_array``  최소  ``mmax+1`` 이상의 길이를 가져야 합니다.


에르미트 함수 (Hermite Functions)
-------------------------

에르미트 함수는 다음과 같이 정의됩니다.

 :math:`$\psi_n(x) = \frac{1}{(2^n n! \sqrt{\pi})^{\frac{1}{2}}} e^{- \frac{x^2}{2}} H_n(x)` $

이 함수는 양자 역학에 나오는 슈뢰딩거 방정식의 조화 진동자 형태를 만족합니다.

 :math:`$\psi_n''(x) + (2n+1-x^2)\psi_n(x) =0` $

이 함수들은 직교하므로 다음을 만족하고,

 :math:`$\int_{-\infty}^{\infty} \psi_m(x)\psi_n(x) \, dx = \delta_{mn}` $

 :math:`L^2 (\mathbb{R})`  공간의 직교 기저를 형성합니다. 에르미트 함수들은 연속 푸리에 변환의 고유 함수이기도 합니다. GSL은 에르미트 함수를 계산하는 두 가지 방법을 제공합니다. 첫 번째는 수학적으로 정의된  :math:`3`  개항의 재귀 관계를 이용합니다. 이 방법은  :math:`O(n)` 의 계산 복잡도를 가지고 가장 정확합니다. 두 번째는 코시 적분 접근 방법을 이용한 방법입니다. 이는 (Bunck, 2009)에 소개 되었으며,  :math:`O(\sqrt{n})` 의 계산복잡도를 가집니다. 정확도를 조금 희생하지만  :math:`n`  값이 클 수록, 기존 방법에 비해 속도에 큰 이점이 있습니다.

>double **gsl_sf_hermite_func**(const int *n*, const double *x*)<br>
>int **gsl_sf_hermite_func_e**(const int *n*, const double *x*, gsl_sf_result * *result*)


이 함수들은 차수  ``n``  에르미트 함수  :math:`\psi_n(x)` 를 주어진 변수  ``x``  대해 계산합니다. 이 방법은 재귀 관계를 이용하며,  :math:`O(n)` 의 계산 복잡도를 가집니다.


>double **gsl_sf_hermite_func_fast**(const int *n*, const double *x*)<br>
>int **gsl_sf_hermite_func_fast_e**(const int *n*, const double *x*, gsl_sf_result * *result*)

이 함수들은 차수  ``n``  에르미트 함수  :math:`\psi_n(x)` 를 주어진 변수  ``x``  대해 계산합니다. 이 방법은 (Bunck, 2009)의 코시 적분을 이용하며,  :math:`O(\sqrt{n})` 의 계산 복잡도를 가집니다.


>int **gsl_sf_hermite_func_array**(const int *nmax*, const double *x*, double * *result_array*)

이 함수는  :math:`n=0, \dots ,nmax` 의 차수를 가지는 에르미트 함수  :math:`\psi_n(x)` 를 주어진 변수  ``x``  대해, 재귀적 방법을 이용해 계산합니다. 계산 결과는  ``result_array``  저장되며 최소  ``nmax+1`` 이상의 길이를 가져야 합니다.

>double **gsl_sf_hermite_func_series**(const int *n*, const double *x*, const double * *a*)<br>
>int **gsl_sf_hermite_func_series_e**(const int *n*, const double *x*, const double * *a*, gsl_sf_result * *result*)

이 함수들은  :math:`\sum_{j=0}^n a_j \psi_j (x)`  급수를 계산합니다.  :math:`\psi_j` 는  :math:`j` 의 차수를 가지는 에르미트 함수를 의미하며, Clenshaw 알고리즘을 이용합니다.


에르미트 함수의 도함수 (Derivatives of Hermite Functions)
-------------------------

>double **gsl_sf_hermite_func_der**(const int *m*, const int *n*, const double *x*)<br>
>int **gsl_sf_hermite_func_der_e**(const int *m*, const int *n*, const double *x*, gsl_sf_result * *result*)

이 함수들은  ``n`` 수의 에르미트 함수  :math:`\psi_n(x)` 의  ``m``  도함수를 주어진  ``x``  대해 계산합니다.


에르미트 함수와 다항식의 근 (Zeros of Hermite Polynomials and Hermite Functions)
-------------------------

이 함수들은 차수  :math:`n` 을 가지는 에르미트 함수와 다항식의  :math:`s`  번째 근을 계산합니다. 각 근들이 원점을 기준으로 대칭이기 때문에, 양수인 근들만 계산됩니다. 인덱스는  :math:`1` 부터 시작해서 오름차순으로 배열됩니다. 홀수 차수의 다항식 만이  :math:`0` 에서  ``0`` 째 근을 가집니다. 해당 값은 항상  :math:`0` 입니다.

>double **gsl_sf_hermite_zero**(const int *n*, const int *s*)<br>
>int **gsl_sf_hermite_zero_e**(const int *n*, const int *s*, gsl_sf_result * *result*)

이 함수들은  ``n`` 수의 에르미트 다항식  :math:`H_n(x)` 의  ``s`` 째 근을 계산합니다.


>double **gsl_sf_hermite_prob_zero**(const int *n*, const int *s*)<br>
>int **gsl_sf_hermite_prob_zero_e**(const int *n*, const int *s*, gsl_sf_result * *result*)

이 함수들은  ``n`` 수의 에르미트 다항식  :math:`H_{e_n}(x)` 의  ``s`` 째 근을 계산합니다.

>double **gsl_sf_hermite_func_zero**(const int *n*, const int *s*)<br>
>int **gsl_sf_hermite_func_zero_e**(const int *n*, const int *s*, gsl_sf_result * *result*)

이 함수들은  ``n`` 차수의 에르미트 함수  :math:`\psi_n(x)` 의  ``s`` 번째 근을 계산합니다.

# 초기하 함수 (Hypergeometric Functions)

초기하 함수들은 Abramowitz& Stegun의 13, 15 단원의 기술을 기반으로 작성되었습니다. 이 함수들은 헤더 파일  ``gsl_sf_hyperg.h``  정의 되어있습니다,


>double **gsl_sf_hyperg_0F1**(double *c*, double *x*)<br>
>int **gsl_sf_hyperg_0F1_e**(double *c*, double *x*, gsl_sf_result * *result*)


이 함수들은 초기하 함수 

 :math:`$_0F_1(c,x)` $

를 계산합니다.


>double **gsl_sf_hyperg_1F1_int**(int *m*, int *n*, double *x*)<br>
>int **gsl_sf_hyperg_1F1_int_e**(int *m*, int *n*, double *x, gsl_sf_result * *result*)


이 함수들은 합류 초기하 함수(confluent hypergeometric)

 :math:`$_1F_1(m,n,x) = M(m,n,x)` $

를 정수 인자  ``m``   ``n``  따라 계산합니다.


> double **gsl_sf_hyperg_1F1**(double *a*, double *b*, double *x*)<br>
> int **gsl_sf_hyperg_1F1_e**(double *a*, double *b*, double *x*, gsl_sf_result * *result*)

이 함수들은 합류 초기하 함수

 :math:`$_1F_1(a,b,x) = M(a,b,x)` $

를 일반 인자  ``a``   ``b``  따라 계산합니다.


>double **gsl_sf_hyperg_U_int**(int *m*, int *n*, double *x*)<br>
>int **gsl_sf_hyperg_U_int_e**(int *m*, int *n*, double *x*, gsl_sf_result * *result*)


이 함수들을 합류 초기하 함수  :math:`U(m,n,x)` 를 정수 인자  ``m``   ``n``  대해 계산합니다.


>int **gsl_sf_hyperg_U_int_e10_e**(int *m*, int *n*, double *x*, gsl_sf_result_e10 * *result*)

이 함수들을 합류 초기하 함수  :math:`U(m,n,x)` 를 정수 인자  ``m``   ``n``  대해 계산하고 확장된 구간에 대해,  ``gsl_sf_result_e10`` 형의 값을 반환합니다.

>double **gsl_sf_hyperg_U**(double *a*, double *b*, double *x*)<br>
>int **gsl_sf_hyperg_U_e**(double *a*, double *b*, double *x*, gsl_sf_result * *result*)


이 함수들을 합류 초기하 함수  :math:`U(a,b,x)` 를 계산합니다.

>int **gsl_sf_hyperg_U_e10_e**(double *a*, double *b*, double *x*, gsl_sf_result_e10 * *result*)


이 함수들을 합류 초기하 함수  :math:`U(a,b,x)` 를 계산하고 확장된 구간에 대해  ``gsl_sf_result_e10`` 형의 값을 반환합니다.


>double **gsl_sf_hyperg_2F1**(double *a*, double *b*, double *c*, double *x*)<br>
>int **gsl_sf_hyperg_2F1_e**(double *a*, double *b*, double *c*, double *x*, gsl_sf_result * *result*)

이 함수들은 구간  :math:`\|x\|<1` 에 대해, 가우스 초기하 함수

 :math:`$_2F_1(a,b,c,x) = F(a,b,c,x)` $

의 값을 계산합니다. 만약, 인자  :math:`(a,b,c,x)` 가 특이점(singular point)에 너무 가깝다면, 급수 근사가 너무 느려지게 되고 함수는 오류 값  ``GSL_EMAXITER``  반환합니다. 이러한 지점은  :math:`x=1` ,  :math:`c-a-b=m, m \in \mathbf{Z}`  구간에서 발생합니다.  


>double **gsl_sf_hyperg_2F1_conj**(double *aR*, double *aI*, double *c*, double *x*)<br>
>int **gsl_sf_hyperg_2F1_conj_e**(double *aR*, double *aI*, double *c*, double *x*, gsl_sf_result * *result*)

이 함수들은 구간  :math:`\|x\|<1` 에 대해, 가우스 초기하 함수

 :math:`$_2F_1 (a_R + i a_I , aR-iaI, c, x)` $

의 복소수 인자 값을 계산합니다.

>double **gsl_sf_hyperg_2F1_renorm**(double *a*, double *b*, double *c*, double *x*)<br>
>int **gsl_sf_hyperg_2F1_renorm_e**(double *a*, double *b*, double *c*, double *x*, gsl_sf_result * *result*)
 
이 함수들은 구간  :math:`\|x\|<1` 에 대해, 재규격화 된 가우스 초기하 함수 

 :math:`$\frac{_2F_1(a,b,c,x)}{\Gamma(c)}` $

의 값을 계산합니다.

 
>double **gsl_sf_hyperg_2F1_conj_renorm**(double *aR*, double *aI*, double *c*, double *x*)<br>
>int **gsl_sf_hyperg_2F1_conj_renorm_e**(double *aR*, double *aI*, double *c*, double *x*, gsl_sf_result * *result*)

 
이 함수들은 구간  :math:`\|x\|<1` 에 대해, 재규격화 된 가우스 초기하 함수 

 :math:`$\frac{_2F_1(a_R + ia_I,a_R - i a_I,c,x)}{\Gamma(c)}` $

의 값을 계산합니다.
 
>double **gsl_sf_hyperg_2F0**(double *a*, double *b*, double *x*)<br>
>int **gsl_sf_hyperg_2F0_e**(double *a*, double *b*, double *x*, gsl_sf_result * *result*)

이 함수들은 초기하 함수

 :math:`$_2F_0(a,b,x)` $
를 계산합니다.

급수 표현은 발산하는 초기하 급수입니다. 하지만,  :math:`x<0`  이라면 다음을 얻을 수 있습니다.

 :math:`$_2F_0 (a,b,x) = (-\frac{1}{x})^a U(a, 1+a, -b,- \frac{1}{x})` $

# 라게르 함수 (Laguerre Functions)

일반화된 라게르 다항식은 (다른 이름으로 버금 라게르 다항식이 있습니다.), 합류 초기하 함수(confluent hypergeometric function)으로 정의됩니다.

 :math:`$L_n^a (x) = \frac{(a+1)_n}{n!} {}_1F_1(-n,a+1,x)` $

 :math:`(a)_n` 는 포흐하머 기호(Pochhammer symbol)입니다. 이들은 일반적인 라게르 다항식  :math:`L_n(x)` 과 다음의 관계를 가집니다. 

 :math:`$L_n^0(x) = L_n(x)` $  

 :math:`$L_n^k(x) = (-1)^k (d^k /d x^k)L_{(n+k)}(x)` $ 

더 자세한 정보는  Abramowitz & Strgun, Chapter 22를 참조할 수 있습니다.

이 단원에서 기술된 함수들은 헤더 파일  ``gsl_sf_laguerre.h``  정의되어 있습니다.

>double **gsl_sf_laguerre_1**(double *a*, double *x*)<br>
>double **gsl_sf_laguerre_2**(double *a*, double *x*)<br>
>double **gsl_sf_laguerre_3**(double *a*, double *x*)<br>
>int **gsl_sf_laguerre_1_e**(double *a*, double *x*, gsl_sf_result * *result*)<br>
>int **gsl_sf_laguerre_2_e**(double *a*, double *x*, gsl_sf_result * *result*)<br>
>int **gsl_sf_laguerre_3_e**(double *a*, double *x*, gsl_sf_result * *result*)<br>

이 함수들은 일반화된 라게르 다항식  :math:`L_1^a (x), L_2^a (x), L_3^a (x)` 을 수학 정의식을 이용해 계산합니다.


>double **gsl_sf_laguerre_n**(const int *n*, const double *a*, const double *x*)<br>
>int **gsl_sf_laguerre_n_e**(intn , double *a*, double *x*, gsl_sf_result * *result*)


이 함수들은 일반화된 라게르 다항식  :math:`L_n^a(x)` 를  :math:`a > -1, n \geq 0` 인 경우를 계산합니다.

# 람베르트  :math:`W`  함수 (Lambert  :math:`W`  Functions)

람베르트  :math:`W`  함수  :math:`W(x)` 는  :math:`W(x)\exp(W(x)) = x`  방정식의 해로 정의됩니다. 이 함수는  :math:`x<0` 에서 다양한 부분 함수들로 나뉘어 집니다. 하지만,  :math:`2`  개의 실수 함수들이 존재합니다. 일반적으로  :math:`W_0(x)` 를 주 함수로 사용합니다. 이 함수는  :math:`x<0` 에 대해,  :math:`W>-1`  값을 가집니다. 그리고,  :math:`w_{-1}(x)` 는 또다른 실수 함수로  :math:`x<0` 에 대해,  :math:`W<-1`  값을 가집니다. 람베르트 함수들은 헤더 파일  ``gsl_sf_lambert.h``  정의되어 있습니다.

>double **gsl_sf_lambert_W0**(double *x*)<br>
>int **gsl_sf_lambert_W0_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 주 람베르트  :math:`W`  함수  :math:`W_0(x)`  값을 계산합니다.


>double **gsl_sf_lambert_Wm1**(double *x*)<br>
>int **gsl_sf_lambert_Wm1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 두 번째 실수 람베르트  :math:`W`  함수  :math:`W_{-1](x)`  값을 계산합니다.

# 르장드르 함수와 구면조화 함수 (Legendre Functions and Spherical Harmonics)

르장드르 다항식과 함수들은 Abramowitz & Stegun Chapter 8. 에 기술되어있습니다. 이 함수들은  ``gsl_sf_legnedre.h`` 헤더 파일에 정의되어 있습니다.

르장드르 다항식(Legendre Polynomials)
-------------------------

>double **gsl_sf_legendre_P1**(double *x*)<br>
>double **gsl_sf_legendre_P2**(double *x*)<br>
>double **gsl_sf_legendre_P3**(double *x*)<br>
>int **gsl_sf_legendre_P1_e**(double *x*, gsl_sf_result * *result*)<br>
>int **gsl_sf_legendre_P2_e**(double *x*, gsl_sf_result * *result*)<br>
>int **gsl_sf_legendre_P3_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 르장드르 다항식  :math:`P_l (x)` 을  :math:`l= 1, 2, 3` 에 대해 계산합니다. 이 계산은 해당 함수들의 정의식을 사용합니다.

>double **gsl_sf_legendre_Pl**(int *l*, double *x*)<br>
>int **gsl_sf_legendre_Pl_e**(int *l*, double *x*, gsl_sf_result * *result*)

이 함수들은 르장드르 다항식  :math:`P_l(x)` 을 주어진  ``l``   ``x``  대해 계산합니다. 이때,  ``l``   ``x``   :math:`l \geq 0` 과  :math:`|x| \leq 1` 을 만족해야 합니다.


>int **gsl_sf_legendre_Pl_array**(int *lmax*, double *x*, double *result_array*[])<br>
>int **gsl_sf_legendre_Pl_deriv_array**(int *lmax*, double *x*, double *result_array*[], double *result_deriv_array*[])

이 함수들은  :math:`l= 0, \dots lmax` 와  :math:`|x| \leq 1` 에 대해, 르장드르 다항식  :math:`P_l(x)` 과 그 도함수  :math:`dP_l (x)/dx` 를 주어진 배열  ``result_array[]``  계산합니다.

>double **gsl_sf_legendre_Q0**(double *x*)<br>
>int **gsl_sf_legendre_Q0_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 과  :math:`x \neq 1` 에 대해, 르장드르 함수  :math:`Q_0(x)` 를 계산합니다.

>double **gsl_sf_legendre_Q1**(double *x*)<br>
>int **gsl_sf_legendre_Q1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 과  :math:`x \neq 1` 에 대해, 르장드르 함수  :math:`Q_1(x)` 를 계산합니다.

>double **gsl_sf_legendre_Ql**(int *l*, double *x*)<br>
>int **gsl_sf_legendre_Ql_e**(int *l*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` ,  :math:`x \neq 1` 과  :math:`l \geq 0`  르장드르 함수  :math:`Q_l(x)` 를 계산합니다.

버금 르장드르 함수와 구면 조화 함수 (Associated Legendre Polynomials and Spherical Harmonics)
-------------------------

이 단원의 함수들은 버금 르장드르 함수  :math:`P_l^m(x)` 의 값을 계산합니다. 이 함수는 다음 미분 방정식의 해입니다.

 :math:`$(1-x^2) \frac{d^2}{d x^2}P_l^m(x) -2x \frac{d}{dx}P_l^m(x) + (l(l+1) - \frac{m^2}{1-x^2})P_l^m(x) =0` $

 :math:`l` 과  :math:`m` 은  :math:`0 \leq l` 과  :math:`0 \leq m \leq l` 을 만족합니다. 함수  :math:`P_l^m(x)`  조합적으로 상승하며  :math:`l` 이  :math:`150` 보다 클 경우 오버플로우가 발생합니다. 이를 대신해서 정규화 된 버금 르장드르 함수를 계산할 수 있습니다. 다양한 종류의 정규화 표현이 존재하고, 이 함수들은 degree와 order가  :math:`2700` 까지 안정적으로 계산할 수 있습니다. 이 라이브러리에서는 다음의 정규화 표현을 제공합니다.

* 슈미트 반 정규화 (Schmidt semi-normalization)

  슈미트 반 정규화 버금 르장드르 함수는 자기 교환 계산에 빈번히 사용됩니다. 이는 다음과 같이 계산할 수 있습니다.

   :math:`$S_l^0 (x) = P_l^0 (x)` $
   :math:`$S_l^m (x) = (-1)^m \sqrt{2 \frac{(l-m)!}{(l+m)!}}P_l^m (x), m > 0` $

  계수  :math:`(-1)^m` 은 Condon-Shortley 위상 계수로 불리며, 필요시 함수에서  ``csphase =1``  인자를 설정해 무시할 수 있습니다.

* 구면 조화 정규화 (Spherical Harmonic Normalization)<br>
  버금 르장드르 함수는 다음과 같이 구면 조화 함수를 계산하는 데 쓸 수 있습니다.

   :math:`$Y_l^m(x) = (-1)^m \sqrt{\frac{2l+1}{4 \pi}\frac{(l-m)!}{(l+m)!}} P_l^m(x)` $

  계수  :math:`(-1)^m` 은 필요시 계산에서 제외할 수 있습니다. 
   

* 완전 정규화 (Full Normalization)
  
  완전 정규화된 버금 르장드르 다항식은 다음과 같이 정의됩니다.

   :math:`$N_l^m(x) = (-1)^m \sqrt{(1+ \frac{1}{2}\frac{(l-m)!}{(l+m)!}}P_l^m(x)` $
  이 때, 다음과 같은 성질을 가집니다.

   :math:`$\int_{-1}^1 N_l^m(x) \, dx = 1` $

아래에 나올 정규화된 버금 르장드르 함수를 계산하는 함수들은 재귀적 방법을 사용합니다. 이 방법은 degree  :math:`l` 과 order  :math:`m` 이 2700 이하라면, 안정적으로 계산할 수 있습니다. 이 값을 넘어서면 계산 함수들은 언더플로우를 일으켜 부정확한 값을 반환합니다. 각 함수들은  :math:`1` -계 도함수  :math:`dP_l^m(x)/dx` 와  :math:`2` -계 도함수  :math:`d^2 P_l^m(x)/ dx^2` 을 제공하며, 이와 함께  :math:`dP_l^m(\cos\theta) / d \theta` 와  :math:`d^2 P_l^m(\cos\theta)/d\theta^2` 도 같이 제공합니다. 이 두 종류의 도함수들은 단순한 비례 관계를 가집니다.  :math:`\theta` 에 관한 미분은 구면 조화 함수에서 매우 빈번히 사용되기 때문에 이 기능 또한 같이 제공하고 있습니다.

아래의 함수에서  ``gsl_sf_legendre_t`` 인자를 이용해 정규화 방법을 선택할 수 있습니다. 가능한 값들은 다음과 같습니다.

>type **gsl_sf_legendre_t**

| 값 | 설명|
|:--:|:--:|
| ``GSL_SF_LGENDRE_NONE``  비 정규화된 버금 르장드르 다항식  :math:`P_l^m(x)` |
| ``GSL_SF_LGENDRE_SCHMIDT`` 슈미트 반 정규화된 버금 르장드르 다항식  :math:`S_l^m(x)` |
| ``GSL_SF_LGENDRE_SPHARM`` 구면 조화 버금 르장드르 다항식  :math:`Y_l^m(x)` |
| ``GSL_SF_LGENDRE_FULL``  완전 정규화 버금 르장드르 다항식  :math:`N_l^m(x)` |


>int **gsl_sf_legendre_array**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, double *result_array*[])<br>
>int **gsl_sf_legendre_array_e**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, const gsdouble *csphase*, double *result_array*[])

이 함수들은 정규화된 버금 르장드르 다항식들을,  :math:`0 \leq l \leq lmax` ,  :math:`0 \geq m \geq l`  그리고  :math:`|x| \leq 1` 에 대해 계산합니다.  ``norm`` 인자는 어느 정규화 방법을 사용할지 결정합니다. 정규화된  :math:`P_l^m(x)`  값들은  ``result_array``  저장됩니다. 이 값은  ``gsl_sf_lengendre_array_n()``  호출해 최소 크기를 결정할 수 있습니다.

배열  :math:`P_l^m(x)` 의 지수는  ``gsl_sf_legendre_array_index(l, m)``  호출해 얻을 수 있습니다.  ``_e``  붇은 함수에서 Condon-Shortly 위상 계수  :math:`(-1)^m` 의 포함 유무를 조정하려면  ``csphase`` 을  :math:`-1` 이나  :math:`1` 로 설정해 주면 됩니다. 이 계수는 기본적으로 비활성화 되어 있습니다.

>int **gsl_sf_legendre_deriv_array**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, double *result_array*[], double *result_deriv_array*[])<br>
>int **gsl_sf_legendre_deriv_array_e**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, const gsdouble *csphase*, double *result_array*[], double *result_deriv_array*[])

이 함수들은  :math:`|x| \leq 1` 값에 대해, 정규화된 버금 르장드르 함수들의  :math:`1` 차에서  ``lmax`` 까지의 도함수 값을 계산합니다.   ``norm`` 인자는 어느 정규화 방법을 사용할지 결정합니다. 르장드르 함수  :math:`P_l^m(x)` 와  :math:`d P_l^m(x)/ dx` 값은 각각  ``result_array``   ``result_deriv_array``  저장됩니다.  ``_e``  붇은 함수에서 Condon-Shortly 위상 계수  :math:`(-1)^m` 의 포함 유무를 조정하려면  ``csphase`` 을  :math:`-1` 이나  :math:`1` 로 설정해 주면 됩니다. 이 계수는 기본적으로 비활성화 되어 있습니다.

>int **gsl_sf_legendre_deriv_alt_array**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, double *result_array*[], double *result_deriv_array*[])<br>
>int **gsl_sf_legendre_deriv_alt_array_e**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, const gsdouble *csphase*, double *result_array*[], double *result_deriv_array*[])

이 함수들은  :math:`|x| \leq 1` 값에 대해,  :math:`1` 차에서  ``lmax`` 까지의 정규화된 버금 르장드르 함수의 값과 대체된 도함수 값을 계산합니다. 르장드르 함수  :math:`P_l^m(x)` 와  :math:`d P_l^m(\cos(\theta))/ d\theta` 의 값들은 각각  ``result_array``   ``result_deriv_array``  저장됩니다.  ``_e``  붇은 함수에서 Condon-Shortly 위상 계수  :math:`(-1)^m` 의 포함 유무를 조정하려면  ``csphase`` 을  :math:`-1` 이나  :math:`1` 로 설정해 주면 됩니다. 이 계수는 기본적으로 비활성화 되어 있습니다.

>int **gsl_sf_legendre_deriv2_array**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, double *result_array*[], double *result_deriv_array*[], double *result_deriv2_array*[])<br>
>int **gsl_sf_legendre_deriv2_array_e**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, const gsdouble *csphase*, double *result_array*[], double *result_deriv_array*[], double *result_deriv2_array*[])

이 함수들은  :math:`|x| \leq 1` 값에 대해,  :math:`1` 차에서  ``lmax`` 까지의 정규화된 버금 르장드르 함수들, 그 도함수들과  :math:`2` 계 도함수 값들을 계산합니다.  ``norm`` 인자는 어느 정규화 방법을 사용할지 결정합니다. 르장드르 함수  :math:`P_l^m(x)` 와  :math:`d P_l^m(x)/ dx` , 그리고  :math:`2` 계 도함수  :math:`d^2 P_l^m(x) / dx^2` 의 값은 각각  ``result_array``   ``result_deriv_array`` 그리고  ``result_deriv2_array``  저장됩니다.  ``_e``  붇은 함수에서 Condon-Shortly 위상 계수  :math:`(-1)^m` 의 포함 유무를 조정하려면  ``csphase`` 을  :math:`-1` 이나  :math:`1` 로 설정해 주면 됩니다. 이 계수는 기본적으로 비활성화 되어 있습니다.


>int **gsl_sf_legendre_deriv2_alt_array**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, double *result_array*[], double *result_deriv_array*[], double *result_deriv2_array*[])<br>
>int **gsl_sf_legendre_deriv2_alt_array_e**(const gsl_sf_legendre_t *norm*, const size_t *lmax*, const double *x*, const gsdouble *csphase*, double *result_array*[], double *result_deriv_array*[], double *result_deriv2_array*[])

이 함수들은  :math:`|x| \leq 1` 값에 대해,  :math:`1` 차에서  ``lmax`` 까지의 정규화된 버금 르장드르 함수들, 그 대체 도함수들과  :math:`2` 계 도함수 값들을 계산합니다.  ``norm`` 인자는 어느 정규화 방법을 사용할지 결정합니다. 르장드르 함수  :math:`P_l^m(x)` 와  :math:`d P_l^m(\cos(\theta))/ d\theta` , 그리고  :math:`2` 계 도함수  :math:`d^2 P_l^m(\cos(\theta)) / d\theta^2` 의 값은 각각  ``result_array``   ``result_deriv_array`` 그리고  ``result_deriv2_array``  저장됩니다.  ``_e``  붇은 함수에서 Condon-Shortly 위상 계수  :math:`(-1)^m` 의 포함 유무를 조정하려면  ``csphase`` 을  :math:`-1` 이나  :math:`1` 로 설정해 주면 됩니다. 이 계수는 기본적으로 비활성화 되어 있습니다.

>size_t **gsl_sf_legendre_nlm**(const size_t *lmax*)

이 함수는  ``lmax`` 지의 버금 르장드르 함수  :math:`P_l^m(x)` 의 갯수를 반환합니다. 해당 값은  ``(lmax_1)* (lmax+2)/2`` 니다.

>size_t **gsl_sf_legendre_array_n**(const size_t *lmax*)

이 함수는 최대 차수  ``lmax`` 지의 배열 버전 버금 르장드르 함수에 필요한 최소 배열의 크기를 반환합니다. 이 값은  :math:`P_l^m(x)` 의 최댓값과 재귀식을 계산할 때 필요한, 곱 계수 계산을 위한 공간을 더한 값입니다.

>size_t **gsl_sf_legendre_array_index**(const size_t *l*, const size_t *m*)

이 함수는  ``result_array``   ``result_deriv_array``  그리고  ``result_deriv2_array`` 배열의 색인 값을 반환합니다. 해당 값은  :math:`P_l^m(x)` ,  :math:`P'_l^m(x)` , 그리고  :math:`P''_l^m(x)` 에 대응되고 주어진  ``l``   ``m``  대해,  :math:`l(l_1)//2 +m` 으로 정해집니다.

 ``HAVE_INLINE``  사용하면 인라인 버전의 함수를 사용할 수 있습니다.

>double **gsl_sf_legendre_Plm**(int *l*, int *m*, double *x*)<br>
>int **gsl_sf_legendre_Plm_e**(int *l*, int *m*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`m \geq 0, l \geq m` 그리고  :math:`|x| \leq 1` 에 대해, 버금 르장드르 함수  :math:`P_l^m(x)` 의 값을 계산합니다.


>double **gsl_sf_legendre_sphPlm**(int *l*, int *m*, double *x*)<br>
>int **gsl_sf_legendre_sphPlm_e**(int *l*, int *m*, double *x*, gsl_sf_result * *result*)

이 함수들은 구면 조화 함수에서 사용하기 위한, 정규회된 버금 르장드르 다항식  :math:`\sqrt{(2l+1)/(4\pi)} \sqrt{(l-m)! / (l+m)!} P_l^m(x)`  값을 계산합니다. 앞의 계수는  :math:`m \geq 0, l \geq m`  그리고  :math:`|x| \leq 1` 를 만족해야합니다. 이 함수들은 표준 정규화과정에서 일어나는 오버플로우를 피할 수 있습니다.

>int **gsl_sf_legendre_Plm_array**(int *l*max, int *m*, double *x*, double *result_array*[])<br>
>int **gsl_sf_legendre_Plm_deriv_array**(int *l*max, int *m*, double *x*, double *result_array*[], double *result_deriv_array*[])

이 함수들은 현재 비활성화 되어 있고 차후 버전에서 삭제될 예정입니다.  ``gsl_sf_legendre_array()``   ``gsl_sf_legendre_deriv_array()``  참고하세요.


>int **gsl_sf_legendre_sphPlm_array**(int *l*max, int *m*, double *x*, double *result_array*[])<br>
>int **gsl_sf_legendre_sphPlm_deriv_array**(int *l*max, int *m*, double *x*, double *result_array*[], double *result_deriv_array*[])

이 함수들은 현재 비활성화 되어 있고 차후 버전에서 삭제될 예정입니다.  ``gsl_sf_legendre_array()``   ``gsl_sf_legendre_deriv_array()``  참고하세요.

>int gsl_sf_legendre_array_size(const int *lmax*, const int *m*)

이 함수는 현재 비활성화 되어 있고 차후 버전에서 삭제될 예정입니다.

원뿔 함수 (Conial Functions)
-------------------------

원통 함수  :math:`P_{-(1/2)+i\lambda}^\mu` 와  :math:`Q^{\mu}_{-(1/2)+i\lambda}` 는 Abramowitz & Stegun 8.12 단원에 기술되어 있습니다.

> double gsl_sf_conicalP_half(double *lambda*, double *x*)<br>
> int gsl_sf_conicalP_half_e(double *lambda*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 에 대해, 비정칙 구면 원뿔 함수  :math:`P_{-1/2+i\lambda}^{1/2} (x)` 값을 계산합니다.

> double gsl_sf_conicalP_mhalf(double *lambda*, double *x*)<br>
> int gsl_sf_conicalP_mhalf_e(double *lambda*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 에 대해, 정칙 구면 원뿔 함수  :math:`P_{-1/2+i\lambda}^{1/2} (x)` 값을 계산합니다.


> double gsl_sf_conicalP_0(double *lambda*, double *x*)<br>
> int gsl_sf_conicalP_0_e(double *lambda*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 에 대해, 원뿔 함수  :math:`P_{-1/2+i\lambda}^{0} (x)` 값을 계산합니다.

> double gsl_sf_conicalP_1(double *lambda*, double *x*)<br>
> int gsl_sf_conicalP_1_e(double *lambda*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 에 대해, 원뿔 함수  :math:`P_{-1/2+i\lambda}^{1} (x)` 값을 계산합니다.

> double gsl_sf_conicalP_sph_reg(int *l*, double *lambda*, double *x*)<br>
> int gsl_sf_conicalP_sph_reg_e(int *l*, double *lambda*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` ,  :math:`l \geq -1` 에 대해, 정칙 구면 원뿔 함수  :math:`P_{1/2+i\lambda}^{-1/2-l} (x)` 값을 계산합니다.

> double gsl_sf_conicalP_cyl_reg(int *m*, double *lambda*, double *x*)<br>
> int gsl_sf_conicalP_cyl_reg_e(int *m*, double *lambda*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` ,  :math:`m \geq -1` 에 대해, 정칙 원통 원뿔 함수  :math:`P_{1/2+i\lambda}^{-m} (x)` 값을 계산합니다.


쌍곡 공간에서의 방사 함수 (Radial Functions for Hyperbolic Space)
-------------------------

다음의 구면 함수들은  :math:`3`  차원 쌍곡 공간  :math:`H^3` 의 라플라시안의 고유 함수들인 르장드르 함수들입니다. 특히 주목되는 부분은 평평한 극한(flat limit)로  :math:`\lambda \rightarrow \infty, \eta \rightarrow 0` 이고,  :math:`\lambda \eta` 가 상수로 고정된 상황입니다.

> double gsl_sf_legendre_H3d_0(double *lambda*, double *eta*)<br>
> int gsl_sf_legendre_H3d_0_e(double *lambda*, double *eta*, gsl_sf_result * *result*)

이 함수들은  :math:`3`  차원 쌍곡 공간 라플라시안의  :math:`0` 차 고유 함수를 계산합니다. 이 함수는 다음과 같이 정의되어 있습니다.  :math:`\eta \geq 0` 에 대해, 

 :math:`$L_0^{H 3d} (\lambda, \eta) := \frac{\sinn(\lambda \eta)}{\lambda \sinh(\eta)}` $

평평한 극한값은  :math:`L_0^{H 3d} (\lambda ,\eta) = j_0(\lambda \eta)` 의 형태를 가집니다.

> double gsl_sf_legendre_H3d_1(double *lambda*, double *eta*)<br>
> int gsl_sf_legendre_H3d_1_e(double *lambda*, double *eta*, gsl_sf_result * *result*)

이 함수들은  :math:`3`  차원 쌍곡 공간 라플라시안의  :math:`1` 차 고유 함수를 계산합니다. 이 함수는 다음과 같이 정의되어 있습니다.  :math:`\eta \geq 0` 에 대해, 

 :math:`$L_1^{H 3d} (\lambda, \eta) := \frac{1}{\sqrt{\lambda^2 +1}}(\frac{\sinn(\lambda \eta)}{\lambda \sinh(\eta)}) (\coth(\eta) - \lambda \cot(\lambda \eta))` $

평평한 극한값은  :math:`L_1^{H 3d} (\lambda ,\eta) = j_1(\lambda \eta)` 의 형태를 가집니다.

> double gsl_sf_legendre_H3d(int *l*, double *lambda*, double *eta*)<br>
> int gsl_sf_legendre_H3d_e(int *l*, double *lambda*, double *eta*, gsl_sf_result * *result*)

이 함수들은  :math:`\eta \geq 0, l \geq 0` 에 대해,  ``l`` 차수의 방사 고유 함수값을 계산합니다. 이 고유 함수들은  :math:`3`  차원 쌍곡 공간의 라플라시안의 고유 함수들입니다. 평평한 극한값은  :math:`L_l^{H 3d} (\lambda ,\eta) = j_l (\lambda \eta)` 형태를 가집니다.

> int gsl_sf_legendre_H3d_array(int *lmax*, double *lambda*, double *eta*, double *result_array*[])

이 함수는  :math:`0 \leq l \leq lmax` 방사 고유 함수  :math:`L_l^{H 3d} (\lambda, \eta)` 의 값을 계산합니다.

# 로그 함수


로그 함수에 관한 정보와 그 성질들은 Abramowitz & Stegun, Chapter 4를 참고할 수 있습니다. 이 단원에서 기술된 함수들은 헤더 파일  ``gsl_sf_log.h``  기술되어 있습니다.

>double **gsl_sf_log(double *x*)**<br>
>int **gsl_sf_log_e**(double *x*, gsl_sf_result * * *result*)

이 함수는  :math:`x>0` 인  ``x``  대해,  :math:`\log(x)` 의 값을 계산합니다.

>double **gsl_sf_log_abs**(double *x*)<br>
>int **gsl_sf_log_abs_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x \neq 0` 인  ``x``  대해,  :math:`\log(|x|)` 을 계산합니다.

>int **gsl_sf_complex_log_e**(double *zr*, double *zi*, gsl_sf_result * *lnr*, >gsl_sf_result * *theta*)

이 함수는 복소수  :math:`z= z_r + i z_i` 의 로그값을 계산합니다. 결과 값은  ``lnr``  ``theta`` 에 각각 저장되며, 다음과 같은 관계를 가집니다.  :math:`\exp(lnr + i \theta) = z_r + i z_i` ,  :math:`\theta` 는  :math:`[-\pi, \pi]` 의 범위를 가집니다.

>double **gsl_sf_log_1plusx**(double *x*)<br>
>int **gsl_sf_log_1plusx_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 에 대해,  :math:`\log(1+x)` 의 값을 계산합니다. 이 함수에서 사용한 알고르즘은 작은  ``x``  대해 정확합니다.

>double **gsl_sf_log_1plusx_mx**(double *x*)<br>s
>int **gsl_sf_log_1plusx_mx_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x>-1` 에 대해,  :math:`\log(1+x)-x` 의 값을 계산합니다. 이 함수에서 사용한 알고르즘은 작은  ``x``  대해 정확합니다.

# 마티유 함수 (Mathieu Functions)


마티유 함수들은 단일 차수나 복수 차수의 함수가 있으며, 배열에 기반한 방법을 통해 계산할 수 있습니다. 배열 기반 함수들은 사전 정의된 작업 공간이 필요합니다.

마티유 함수 작업 공간 (Mathieu Function Workspace)
-------------------------

> type **gsl_sf_mathieu_workspace**

이 공간은 배열 기반 방법을 위한 작업 공간입니다.

> gsl_sf_mathieu_workspace * **gsl_sf_mathieu_alloc**(size_t *n*, double *qmax*)

이 함수는 마티유 함수들의 배열 기반 방법을 위한 작업 공간을 반환합니다. 인자  ``n``   ``qmax``  최대 계수와 공간에서 계산되는 마티유 함수의  :math:`q` -값을 결정합니다.

> void **gsl_sf_mathieu_free**(gsl_sf_mathieu_workspace * *work*)

이 함수는 주어진 작업 공간  ``work``  해제합니다.

마티유 함수 특성 값 (Mathieu Function Characteristic Values)
-------------------------

> int **gsl_sf_mathieu_a**(int *n*, double *q*)
> int **gsl_sf_mathieu_a_e**(int *n*, double *q*, gsl_sf_result * *result*)
> int **gsl_sf_mathieu_b**(int *n*, double *q*)
> int **gsl_sf_mathieu_b_e**(int *n*, double *q*, gsl_sf_result * *result*)

이 함수들은 각각, 마티유 함수  :math:`c e_n (q,x)` 와  :math:`s e_n (q,x)` 의 특성 값  :math:`a_n(q)` 와  :math:`b_n(q)` 을 계산합니다.

> int **gsl_sf_mathieu_a_array**(int *order_min*, int *order_max*, double *q*, igsl_sf_mathieu_workspace * *work*, double *result_array*[])
> int **gsl_sf_mathieu_b_array**(int *order_min*, int *order_max*, double *q*, igsl_sf_mathieu_workspace * *work*, double *result_array*[])

이 함수들은 마티유 함수의 특성 값  :math:`a_n(q)` 와  :math:`b_n(q)` 을 주어진  ``oreder_min``   ``order_max`` 사이 범위에 있는  :math:`n` 에 대해 계산합니다. 계산 결과는  ``result_array``  저장됩니다.

각 운동량 마티유 함수 (Angular Mathieu Functions)
-------------------------

> int **gsl_sf_mathieu_ce**(int *n*, double *q*, double *x*)<br>
> int **gsl_sf_mathieu_ce_e**(int *n*, double *q*, double *x*, gsl_sf_result * *result*)<br>
> int **gsl_sf_mathieu_se**(int *n*, double *q*, double *x*)<br>
> int **gsl_sf_mathieu_se_e**(int *n*, double *q*, double *x*, gsl_sf_result * *result*)

이 함수들은 각각, 각 운동량 마티유 함수  :math:`c e_n (q,x)` 와  :math:`s e_n (q,x)` 를 계산합니다.

> int **gsl_sf_mathieu_ce_array**(int *n*min, int *n*max, double *q*, double *x*, igsl_sf_mathieu_workspace * *work*, double *result_array*[])<br>
> int **gsl_sf_mathieu_se_array**(int *n*min, int *n*max, double *q*, double *x*, igsl_sf_mathieu_workspace * *work*, double *result_array*[])

이 함수들은 각각, 각 운동량 마티유 함수  :math:`c e_n (q,x)` 와  :math:`s e_n (q,x)` 의 값을 주어진  ``nmin``   ``nmax`` 이 범위에 있는  :math:`n` 에 대해 계산합니다. 계산 결과는  ``result_array``  저장됩니다.


방사 마티유 함수 (Radial Mathieu Functions)
-------------------------

> int **gsl_sf_mathieu_Mc**(int *j*, int *n*, double *q*, double *x*)<br>
> int **gsl_sf_mathieu_Mc_e**(int *j*, int *n*, double *q*, double *x*, gsl_sf_result * *result*)<br>
> int **gsl_sf_mathieu_Ms**(int *j*, int *n*, double *q*, double *x*)<br>
> int **gsl_sf_mathieu_Ms_e**(int *j*, int *n*, double *q*, double *x*, gsl_sf_result * *result*)

이 함수들은 각각,  ``j`` 종  ``n``  마티유 함수  :math:`M c_n^{(j)} (q,x)` 와  :math:`M s_n^{(j)} (q,x)` 를 계산합니다.

 ``j`` 값은  :math:`1,2`  로 한정됩니다.  :math:`j=3, 4` 는 다음의 관계를 이용해 계산할 수 있습니다.  :math:`M_n^{(j)} =`   :math:`Mc_n^{(j)}` 나  :math:`Ms_n^{(j)}` 에 대해,  :math:`M_n^{(3)} = M_n^{(1)} + i M_n^{(2)}` 와  :math:`M_n^{(4)} = M_n^{(1)} - i M_n^{(2)}` .

>  int **gsl_sf_mathieu_Mc_array**(int *j*, int *nmin*, int *nmax*, double *q*, double *x*, gsl_sf_mathieu_workspace * *work*, double *result_array*[])<br>
> int **gsl_sf_mathieu_Ms_array**(int *j*, int *nmin*, int *nmax*, double *q*, double *x*, gsl_sf_mathieu_workspace * *work*, double *result_array*[])

이 함수들은  ``j``  메티유 함수의 값을 주어진  ``nmin``   ``nmax`` 이 범위에 있는  :math:`n` 에 대해 계산합니다. 계산 결과는  ``result_array``  저장됩니다.

# 멱함수 (Power Function)

다음의 함수들은 오차 계산과 함께라면, 함수  ``gsl_pow_int()``  같습니다. 이 함수들은 헤더 파일  ``gsl_sf_pow_int.h``  정의되어 있습니다.


>double **gsl_sf_pow_int**(double *x*, int *n*)<br>
>int **gsl_sf_pow_int_e**(double *x*, int *n*, gsl_sf_result * *result*)

이 함수들은 정수  ``n``  대해  :math:`x^n` 의 값을 계산합니다. 이 때, 거듭 제곱은 곱셈 횟수를 최소화해 계산됩니다. 예를 들어서,  :math:`x^8` 을 계산하고자 하면,  :math:`3`  번의 곱셈을 이용해  :math:`((x^2)^2)^2` 으로 계산합니다. 효율성을 위해서 이 함수는 오버 플로우나 언더 플로우 조건을 검사하지 않습니다. 

다음은 간단한 예제입니다.

.. code-block:: c

    #include <gsl/gsl_sf_pow_int.h>
/* compute 3.0**12 */
double y = gsl_sf_pow_int(3.0, 12);


# 프사이(디감마) 함수 (Psi (Digamma) Function)

차수  :math:`n` 의 극 감마 함수는 다음과 같이 정의됩니다.

 :math:`$\psi^{(n)} (x) = (\frac{d}{dx})^n \psi(x) = (\frac{d}{dx})^{n+1} \log(\Gamma(x))` $

 :math:`\psi(x) = \Gamma'(x)/\Gamma(x)` 는 Digamma 함수로 알려져 있습니다. 이 단원의 함수들은 헤더 파일  ``gsl_sf_psi.h``  기술되어 있습니다.

Digamma 함수 (Digamma Function)
-------------------------

>double **gsl_sf_psi_int**(int *n*)<br>
>int **gsl_sf_psi_int_e**(int *n*, gsl_sf_result * *result*)


이 함수들은 digamma 함수  :math:`\psi(n)`  값을 주어진 양의 정수  ``n``  대해 계산합니다. digamma 함수는 프사이(Psi) 함수라고도 불립니다.


>double **gsl_sf_psi**(double *x*)<br>
>int **gsl_sf_psi_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 digamma 함수  :math:`\psi(x)` 를 주어진 값  ``x``  대해 계산합니다. 이때,  :math:`x \neq 0`  입니다.

>double **gsl_sf_psi_1piy**(double *y*)<br>
>int **gsl_sf_psi_1piy_e**(double *y*, gsl_sf_result * *result*)

이 함수들은  :math:`1+iy`  선 위에서의 digamma 함수의 실수부  :math:`\mathfrak{R}[\psi(1+iy)]` 를 계산합니다.

Trigamma 함수 (Trigamma Function)
-------------------------

>double **gsl_sf_psi_1_int**(int *n*)<br>
>int **gsl_sf_psi_1_int_e**(int *n*, gsl_sf_result * *result*)

이 함수들은 Trigamma 함수  :math:`\psi'(n)` 을 주어진 양의 정수  ``n``  대해 계산합니다.


>double **gsl_sf_psi_1**(double *x*)<br>
>int **gsl_sf_psi_1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 Trigamma 함수  :math:`\psi'(x)` 를 주어진 값  ``x``  대해 계산합니다.

Polygamma 함수 (Polygamma Function)
-------------------------

>double **gsl_sf_psi_n**(int *n*, double *x*)<br>
>int **gsl_sf_psi_n_e**(int *n*, double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`n \geq 0, x>0` 인  :math:`n,x` 에 대해, polygamma 함수  :math:`\psi^{(n)}(x)` 를 계산합니다. 

# 싱크트론 함수 (Synchrotron Functions)

이 단원의 함수들은  ``gsl_sf_sychrotron.h`` 해더 파일에 기술되어 있습니다.

>double **gsl_sf_synchrotron_1**(double *x*) <br>
>int **gsl_sf_synchrotron_1_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x \geq 0` 에 대해, 1차 싱크로트론 함수  :math:`x \int_x^\infty K_{5/3} \, dt` 를 계산합니다.

>double **gsl_sf_synchrotron_2**(double *x*)<br>
>int **gsl_sf_synchrotron_2_e**(double *x*, gsl_sf_result * *result*)

이 함수들은  :math:`x \geq 0` 에 대해, 2차 싱크로트론 함수  :math:`x \int_x^\infty K_{2/3} \, dt` 를 계산합니다.



# 운송 함수 (Transport Functions)

운송 함수  :math:`J(n,x)` 는 다음과 같이 적분으로 정의됩니다.

 :math:`$J(n,x) = \int_0^x \frac{t^ne^t}{(e^t -1)^2} \, dx` $

이 함수들은 헤더 파일  ``gsl_sf_transport.h``  정의되어 있습니다.

>double **gsl_sf_transport_2**(double *x*)<br>
>int **gsl_sf_transport_2_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 운송 함수  :math:`J(2,x)` 의 값을 계산합니다.

>double **gsl_sf_transport_3**(double *x*)<br>
>int **gsl_sf_transport_3_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 운송 함수  :math:`J(3,x)` 의 값을 계산합니다.


>double **gsl_sf_transport_4**(double *x*)<br>
>int **gsl_sf_transport_4_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 운송 함수  :math:`J(4,x)` 의 값을 계산합니다.

>double **gsl_sf_transport_5**(double *x*)<br>
>int **gsl_sf_transport_5_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 운송 함수  :math:`J(5,x)` 의 값을 계산합니다.

# 삼각 함수 (Trigonometric Functions)

본 라이브러리는 여러 플랫폼에서 일관적인 코드 작성과 신뢰할 수 있는 오류 측정을 위해 자체적인 삼각 함수를 포함하고 있습니다. 이 함수들은 헤더파일  ``gsl_sf_trig.h``  정의되어 있습니다.

삼각 함수 (Circular Trigonometric Functions)
-------------------------

>double **gsl_sf_sin**(double *x*)<br>
>int **gsl_sf_sin_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 sine 함수  :math:`\sin(x)` 를 계산합니다.

>double **gsl_sf_cos**(double *x*)<br>
>int **gsl_sf_cos_e**(double *x*, gsl_sf_result * *result*)

이 함수들은 cosine 함수  :math:`\cos(x)` 를 계산합니다.

>double **gsl_sf_hypot**(double *x*, double y)<br>
>int **gsl_sf_hypot_e**(double *x*, double y, gsl_sf_result * *result*)

이 함수들은 오버 플로우와 언더 플로우 없는  :math:`\sqrt{x^2+y^2}`  값을 계산합니다.

>double **gsl_sf_sinc**(double *x*)<br>
>int **gsl_sf_sinc_e**(double *x*, gsl_sf_result * *result*)

이 함수는 주어진  ``x`` 에 대해,  :math:`\text{sinc}(x) = \sin(\pi x)/(\pi x)`  값을 계산합니다.

복소 삼각 함수 (Trigonometric Functions for Complex Arguments)
-------------------------

>int **gsl_sf_complex_sin_e**(double *zr*, double *zi*, gsl_sf_result * *szr*, gsl_sf_result * *szi*)

이 함수는 복소 sine 함수  :math:`\sin(z_r + i z_i)`  값을 계산합니다. 계산 값의 실수부는  ``szr``  허수부는  ``szi``  저장됩니다.

>int **gsl_sf_complex_cos_e**(double *zr*, double *zi*, gsl_sf_result * *czr*, gsl_sf_result * *czi*)

이 함수는 복소 cosine 함수  :math:`\cos(z_r + i z_i)`  값을 계산합니다. 계산 값의 실수부는  ``czr``  허수부는  ``czi``  저장됩니다.

>int **gsl_sf_complex_logsin_e**(double *zr*, double *zi*, gsl_sf_result * *lszr*, gsl_sf_result * *lszi*)

이 함수는 sine 함수의 로그 값  :math:`\log(\sin(z_r + i z_i))` 을 계산합니다. 계산 값의 실수부는  ``lszr`` , 허수부는  ``lszi``  저장됩니다.


쌍곡 함수 (Hyperbolic Trigonometric Functions)
-------------------------

>double **gsl_sf_lnsinh**(double *x*)<br>
>int **gsl_sf_lnsinh_e**(double *x*, gsl_sf_result * *result*)

이 함수는  :math:`\log(\text{sinh}(x))`  값을,  :math:`x>0` 에 대해 계산합니다.

>double **gsl_sf_lncosh**(double *x*)<br>
>int **gsl_sf_lncosh_e**(double *x*, gsl_sf_result * *result*)

이 함수는 주어진 값  ``x``  대해,  :math:`\log(\text{cosh}(x))`  값을 계산합니다.

좌표 변환 함수 (Conversion Functions)
-------------------------

>int **gsl_sf_polar_to_rect**(double *r*, double *theta*, gsl_sf_result * *x*, gsl_sf_result * *y*)

이 함수는 극 좌표( ``r``   ``theta`` 를 직교 좌표( ``x``  ``y`` 로 변환합니다.  :math:`x = r \cos(\theta), y= r\sin(\theta)` .


>int **gsl_sf_rect_to_polar**(double *x*, double *y*, gsl_sf_result * *r*, gsl_sf_result * *theta*)

이 함수는 직교 좌표( ``x``  ``y`` 를 극 좌표( ``r``  ``theta`` 로 변환합니다.  :math:`x = r \cos(\theta), y= r\sin(\theta)` .  ``theta``   :math:`[-\pi, \pi]` 의 범위를 가집니다.

각 제한 함수 (Restriction Functions)
-------------------------

>double **gsl_sf_angle_restrict_symm**(double *theta*)<br>
>int **gsl_sf_angle_restrict_symm_e**(double * *theta*)

이 함수들은 각  ``theta`` 값을  :math:`(-\pi, pi]`  범위 내에 있도록 변환합니다.

유의점: 실제  :math:`\pi`  값은  ``M_PI`` 다 조금 큽니다.따라서,  ``M_PI``   ``-M_PI``  이 범위에 포함되어 있습니다.


>double **gsl_sf_angle_restrict_pos**(double *theta*)<br>
>int **gsl_sf_angle_restrict_pos_e**(double * *theta*)

이 함수들은 각  ``theta`` 값을  :math:`(0, 2pi]`  범위 내에 있도록 변환합니다.

유의점: 실제  :math:`2\pi`  값은  ``2M_PI`` 다 조금 큽니다. 따라서,  ``2*M_PI``  이 범위에 포함되어 있습니다.

오차 분석을 포함한 삼각 함수 (Trigonometric Functions With Error Estimates)
-------------------------


>int **gsl_sf_sin_err_e**(double *x*, double *dx*, gsl_sf_result * *result*)

이 함수는 각  ``x``  대해, 버금 절대 오차  ``dx``  포함된 sine 값  :math:`\sin(x \pm dx)` 을 계산합니다. 유의점: 이 함수는 오차 관리 함수 형태만으로 제공됩니다. 이는 이 함수가 오차 전파를 계산하기 위해 제공하는 것이기 때문입니다.

>int **gsl_sf_cos_err_e**(double *x*, double *dx*, gsl_sf_result * *result*)

이 함수는 각  ``x``  대해, 버금 절대 오차  ``dx``  포함된 cosine 값  :math:`\cos(x \pm dx)` 을 계산합니다. 유의점: 이 함수는 오차 관리 함수 형태만으로 제공됩니다. 이는 이 함수가 오차 전파를 계산하기 위해 제공하는 것이기 때문입니다.


# 제타 함수 (Zeta Functions)

리만 제타 함수 (Riemann Zeta Function)
-------------------------

리만 제타 함수는 다음과 같이 무한 급수로 정의됩니다.

 :math:`$\zeta (s) = \sum\_{k=1}^\infty k^{-s}` $


>double **gsl_sf_zeta_int**(int *n*)<br>
>int **gsl_sf_zeta_int_e**(int *n*, gsl_sf_result * *result*)

이 함수는 정수  ``n``  대한 리만 제타 함수  :math:`\zeta(n)` 의 값을 계산합니다. ( :math:`n \neq 1`  이어야 합니다.)


>double **gsl_sf_zeta**(double *s*)<br>
>int **gsl_sf_zeta_e**(double *s*, gsl_sf_result * *result*)



이 함수는 임의의 수  ``s``  대해 리만 제타 함수  :math:`\zeta(s)`  값을 계산합니다. 위 함수와 마찬가지로  :math:`s \neq 1` 이어야 합니다.

리만 제타 함수 -1 (Riemann Zeta Function Minus One)
-------------------------

큰 양수 값에 대해, 리만 제타함수는 1로 수렴하게 됩니다. 이 경우에 1이 아닌 부분의 값이 빈번히 사용되므로, 라이브러리에서는 이를 위한 함수를 제공합니다.


>double **gsl_sf_zetam1_int**(int *n*)<br>
>int **gsl_sf_zetam1_int_e**(int *n*, gsl_sf_result * *result*)


이 함수는 정수  ``n``  대한  :math:`\zeta(n)-1` 의 값을 계산합니다. ( :math:`n \neq 1`  이어야 합니다.)

>double **gsl_sf_zetam1**(double *s*)<br>
>int **gsl_sf_zetam1_e**(double *s*, gsl_sf_result * *result*)


이 함수는 임의의 수  ``s``  대해  :math:`\zeta(s)-1`  값을 계산합니다. 위 함수와 마찬가지로  :math:`s \neq 1` 이어야 합니다.

후르비츠(Hurwitz) 제타 함수 (Hurwitz Zeta Function)
-------------------------

후르비츠 제타함수는 다음과 같이 정의됩니다.

 :math:`$\zeta (s,q) = \sum\_{0}^\infty (k+q)^{-s}` $

>double **gsl_sf_hzeta**(double *s, double *q*)<br>
>int **gsl_sf_hzeta_e**(double *s, double *q*, gsl_sf_result * *result*)


이 명령어는 후르비츠 제타 함수  :math:`\zeta (s,q)` 의 값을 계산합니다.  :math:`s>1, q>0`  이어야 합니다.

에타(Eta) 함수 (Eta Function)
-------------------------

에타 함수는 다음과 같이 정의됩니다.

 :math:`$\eta(s) = (1-2^{1-s}\zeta (s)` $


>double **gsl_sf_eta_int** (int *n*)<br>
>int **gsl_sf_eta_int_e** (int *n*, gsl_sf_result * *result*)

이 명령어는 정수  ``n``  대해 에타 함수  :math:`\eta(n)` 의 값을 계산합니다.


>double **gsl_sf_eta**(double *s*)<br>
>int **gsl_sf_eta_e**(double *s*, gsl_sf_result * *result*)


이 명령어는 임의의 수  ``s``  대해 에타 함수  :math:`\eta(s)` 의 값을 계산합니다.

